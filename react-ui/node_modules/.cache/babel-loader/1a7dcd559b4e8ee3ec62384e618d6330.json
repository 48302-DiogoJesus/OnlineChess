{"ast":null,"code":"/**\r\n * Piece Object\r\n * Schema of a PieceObject\r\n * @property {color} Color of the piece: Black or White\r\n * @property {type} Piece type: Pawn, Rook, Knight, King, Queen, Bishop\r\n */\n\n/**\r\n * Piece Color\r\n */\nexport let PieceColor;\n/**\r\n * Select by PieceColor\r\n * @param {piece} PieceObject to evaluate the color from\r\n * @param {ifWhite} Return this value if [piece] is white\r\n * @param {ifBlack} Return this value if [piece] is black\r\n * @returns {ifWhite} if {piece} is white, {ifBlack} if {ifWhite} is black\r\n */\n\n(function (PieceColor) {\n  PieceColor[\"BLACK\"] = \"b\";\n  PieceColor[\"WHITE\"] = \"w\";\n})(PieceColor || (PieceColor = {}));\n\nexport function selectByPieceColor(piece, ifWhite, ifBlack) {\n  return piece.color === PieceColor.WHITE ? ifWhite : ifBlack;\n}\n/**\r\n * Piece Type\r\n */\n\nexport let PieceType;\n/**\r\n * Char to Piece\r\n * Convert a char to a valid Piece if possible\r\n * If [char] is a valid piece find its color:\r\n * - If char in CAPS: WHITE\r\n * - Else: BLACK\r\n * @param {char} Character to try convert to a PieceObject\r\n * @returns A new PieceObject built from the [char] if valid, null if not\r\n */\n\n(function (PieceType) {\n  PieceType[\"PAWN\"] = \"p\";\n  PieceType[\"KING\"] = \"k\";\n  PieceType[\"QUEEN\"] = \"q\";\n  PieceType[\"ROOK\"] = \"r\";\n  PieceType[\"KNIGHT\"] = \"n\";\n  PieceType[\"BISHOP\"] = \"b\";\n})(PieceType || (PieceType = {}));\n\nexport function charToPiece(char) {\n  if (char.length !== 1) return null; // array.find returns the element if it finds it (a PieceType)\n\n  const pieceType = [PieceType.PAWN, PieceType.KING, PieceType.QUEEN, PieceType.ROOK, PieceType.KNIGHT, PieceType.BISHOP].find(elem => char.toLowerCase() === elem);\n  if (pieceType === undefined) return null;\n  return {\n    color: char.toUpperCase() === char ? PieceColor.WHITE : PieceColor.BLACK,\n    type: pieceType\n  };\n}","map":{"version":3,"sources":["C:/Users/jesus/Desktop/PG/Personal/1-Web/TS/OnlineChess/onlinechess/src/domain/piece.tsx"],"names":["PieceColor","selectByPieceColor","piece","ifWhite","ifBlack","color","WHITE","PieceType","charToPiece","char","length","pieceType","PAWN","KING","QUEEN","ROOK","KNIGHT","BISHOP","find","elem","toLowerCase","undefined","toUpperCase","BLACK","type"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAMA;AACA;AACA;AACA,WAAYA,UAAZ;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;WAXYA,U;AAAAA,EAAAA,U;AAAAA,EAAAA,U;GAAAA,U,KAAAA,U;;AAYZ,OAAO,SAASC,kBAAT,CAA+BC,KAA/B,EAAmDC,OAAnD,EAA+DC,OAA/D,EAA+E;AAClF,SAAOF,KAAK,CAACG,KAAN,KAAgBL,UAAU,CAACM,KAA3B,GAAmCH,OAAnC,GAA6CC,OAApD;AACH;AAED;AACA;AACA;;AACA,WAAYG,SAAZ;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;WAjBYA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;GAAAA,S,KAAAA,S;;AAkBZ,OAAO,SAASC,WAAT,CAAqBC,IAArB,EAAuD;AAC1D,MAAIA,IAAI,CAACC,MAAL,KAAgB,CAApB,EACI,OAAO,IAAP,CAFsD,CAG1D;;AACA,QAAMC,SAAS,GAAG,CAACJ,SAAS,CAACK,IAAX,EAAiBL,SAAS,CAACM,IAA3B,EAAiCN,SAAS,CAACO,KAA3C,EAAkDP,SAAS,CAACQ,IAA5D,EAAkER,SAAS,CAACS,MAA5E,EAAoFT,SAAS,CAACU,MAA9F,EACjBC,IADiB,CACZC,IAAI,IAAIV,IAAI,CAACW,WAAL,OAAuBD,IADnB,CAAlB;AAGA,MAAIR,SAAS,KAAKU,SAAlB,EACI,OAAO,IAAP;AACJ,SAAO;AACHhB,IAAAA,KAAK,EAAEI,IAAI,CAACa,WAAL,OAAuBb,IAAvB,GAA8BT,UAAU,CAACM,KAAzC,GAAiDN,UAAU,CAACuB,KADhE;AAEHC,IAAAA,IAAI,EAAEb;AAFH,GAAP;AAIH","sourcesContent":["/**\r\n * Piece Object\r\n * Schema of a PieceObject\r\n * @property {color} Color of the piece: Black or White\r\n * @property {type} Piece type: Pawn, Rook, Knight, King, Queen, Bishop\r\n */\r\n export interface PieceObject {\r\n    color: PieceColor,\r\n    type: PieceType\r\n}\r\n\r\n/**\r\n * Piece Color\r\n */\r\nexport enum PieceColor { \r\n    BLACK = 'b', \r\n    WHITE = 'w'\r\n}\r\n\r\n/**\r\n * Select by PieceColor\r\n * @param {piece} PieceObject to evaluate the color from\r\n * @param {ifWhite} Return this value if [piece] is white\r\n * @param {ifBlack} Return this value if [piece] is black\r\n * @returns {ifWhite} if {piece} is white, {ifBlack} if {ifWhite} is black\r\n */\r\nexport function selectByPieceColor<T>(piece: PieceObject, ifWhite: T, ifBlack: T) : T {\r\n    return piece.color === PieceColor.WHITE ? ifWhite : ifBlack\r\n}\r\n\r\n/**\r\n * Piece Type\r\n */\r\nexport enum PieceType {\r\n    PAWN = 'p', \r\n    KING = 'k', \r\n    QUEEN = 'q', \r\n    ROOK = 'r', \r\n    KNIGHT = 'n',\r\n    BISHOP = 'b'\r\n}\r\n\r\n/**\r\n * Char to Piece\r\n * Convert a char to a valid Piece if possible\r\n * If [char] is a valid piece find its color:\r\n * - If char in CAPS: WHITE\r\n * - Else: BLACK\r\n * @param {char} Character to try convert to a PieceObject\r\n * @returns A new PieceObject built from the [char] if valid, null if not\r\n */\r\nexport function charToPiece(char: string): PieceObject | null {\r\n    if (char.length !== 1)\r\n        return null\r\n    // array.find returns the element if it finds it (a PieceType)\r\n    const pieceType = [PieceType.PAWN, PieceType.KING, PieceType.QUEEN, PieceType.ROOK, PieceType.KNIGHT, PieceType.BISHOP]\r\n    .find(elem => char.toLowerCase() === elem)\r\n\r\n    if (pieceType === undefined)\r\n        return null\r\n    return {\r\n        color: char.toUpperCase() === char ? PieceColor.WHITE : PieceColor.BLACK,\r\n        type: pieceType\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}