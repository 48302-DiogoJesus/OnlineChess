{"ast":null,"code":"import { charToPiece, selectByPieceColor } from './piece';\nimport { Position } from './position';\nexport const BOARD_WIDTH = 8;\nexport const BOARD_HEIGHT = 8;\n/**\r\n * Board Object\r\n * Representation of a board and all it's permitted operations\r\n */\n\nexport class BoardObject {\n  /**\r\n   * BoardObject Class contructor\r\n   * @param {initBoard} If true it will initialize this.board with pieces at default positions (true by default)\r\n   * @returns A new instance of BoardObject\r\n   */\n  constructor() {\n    let initBoard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.board = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(null));\n\n    this.setPieceAt = (position, piece) => this.board[position.row][position.column] = piece;\n\n    this.getPieceAt = position => this.board[position.row][position.column];\n\n    this.setRow = (rowStr, rowNum) => {\n      for (let colNum = 0; colNum < BOARD_WIDTH; colNum++) {\n        const pieceChar = rowStr[colNum];\n\n        if (pieceChar !== undefined) {\n          this.setPieceAt(Position(colNum, rowNum), charToPiece(rowStr[colNum]));\n        }\n      }\n    };\n\n    if (initBoard) {\n      this.initBoard();\n    }\n  } // The board representation itelf. a matrix with 8 rows and 8 columns\n\n\n  /**\r\n   * Board to String\r\n   * Convert the current board to a string\r\n   * @returns a string representation of this.board\r\n   */\n  toString() {\n    var boardAsString = \"\";\n    this.board.map((row, rowIdx) => row.map((col, colIdx) => {\n      const piece = this.getPieceAt(Position(colIdx, rowIdx));\n\n      if (piece == null) {\n        boardAsString += \" \";\n      } else {\n        boardAsString += selectByPieceColor(piece, piece.type.toUpperCase(), piece.type);\n      }\n    }));\n    return boardAsString;\n  }\n  /**\r\n   * Set Board Row\r\n   * Sets the pieces for a specific row on the board\r\n   * @param {rowStr} Representation of the row as a string of [BOARD_WIDTH] characters\r\n   * @param {rowNum} Row number to identify the row. From 0 to [BOARD_HEIGHT]\r\n   */\n\n\n  /**\r\n   * Initialize Board\r\n   * Set the default rows with the default chess pieces in the current board\r\n   */\n  initBoard() {\n    // Set White pieces\n    this.setRow(\"rnbqkbnr\", 0);\n    this.setRow(\"pppppppp\", 1); // Set Black pieces\n\n    this.setRow(\"PPPPPPPP\", BOARD_HEIGHT - 2);\n    this.setRow(\"RNBQKBNR\", BOARD_HEIGHT - 1);\n  }\n\n}\n/**\r\n * String to Board\r\n * Convert a string to a board\r\n * If a char corresponds to a valid piece set that piece in the {newBoard}, if not set an empty Tile in the {newBoard}\r\n * @param {boardAsString} Example of a default board: \"rnbqkbnrpppppppp                                PPPPPPPPRNBQKBNR\"\r\n * @returns A new BoardObject if {boardAsString} is convertible to a board, null if not\r\n */\n\nfunction stringToBoard(boardAsString) {\n  if (boardAsString.length < BOARD_WIDTH * BOARD_HEIGHT) return null;\n  const newBoard = new BoardObject();\n\n  for (let row = 0, currChar = 0; row < BOARD_HEIGHT; row++) {\n    for (let col = 0; col < BOARD_WIDTH; col++, currChar++) {\n      const pieceChar = boardAsString[currChar];\n      const piece = charToPiece(pieceChar); // [piece] will be null if char does not correspond to a piece. Case of the \" \" representing an empty Tile\n\n      newBoard.setPieceAt(Position(col, row), piece);\n    }\n  }\n\n  return newBoard;\n}\n\nconst B1 = new BoardObject();\nconst B1S = B1.toString();\nconst B2 = B1S.toBoard();\nconsole.log(B1S == B2.toString());\n\nString.prototype.toBoard = function (boardAsString) {\n  if (boardAsString.length < BOARD_WIDTH * BOARD_HEIGHT) return null;\n  const newBoard = new BoardObject();\n\n  for (let row = 0, currChar = 0; row < BOARD_HEIGHT; row++) {\n    for (let col = 0; col < BOARD_WIDTH; col++, currChar++) {\n      const pieceChar = boardAsString[currChar];\n      const piece = charToPiece(pieceChar); // [piece] will be null if char does not correspond to a piece. Case of the \" \" representing an empty Tile\n\n      newBoard.setPieceAt(Position(col, row), piece);\n    }\n  }\n\n  return newBoard;\n};","map":{"version":3,"sources":["C:/Users/jesus/Desktop/TS/OnlineChess/onlinechess/src/domain/board.tsx"],"names":["charToPiece","selectByPieceColor","Position","BOARD_WIDTH","BOARD_HEIGHT","BoardObject","constructor","initBoard","board","Array","fill","map","setPieceAt","position","piece","row","column","getPieceAt","setRow","rowStr","rowNum","colNum","pieceChar","undefined","toString","boardAsString","rowIdx","col","colIdx","type","toUpperCase","stringToBoard","length","newBoard","currChar","B1","B1S","B2","toBoard","console","log","String","prototype"],"mappings":"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","sourcesContent":["import { PieceObject, charToPiece, selectByPieceColor } from './piece'\r\nimport { PositionObject, Position } from './position'\r\n\r\nexport const BOARD_WIDTH = 8;\r\nexport const BOARD_HEIGHT = 8;\r\n\r\n/**\r\n * Board Object\r\n * Representation of a board and all it's permitted operations\r\n */\r\nexport class BoardObject {\r\n\r\n  /**\r\n   * BoardObject Class contructor\r\n   * @param {initBoard} If true it will initialize this.board with pieces at default positions (true by default)\r\n   * @returns A new instance of BoardObject\r\n   */ \r\n  constructor(initBoard: boolean = true) {\r\n    if (initBoard) {\r\n      this.initBoard()\r\n    }\r\n  }\r\n\r\n  // The board representation itelf. a matrix with 8 rows and 8 columns\r\n  board: Array<Array<PieceObject | null>> = Array(BOARD_HEIGHT).fill(null).map(()=>Array(BOARD_WIDTH).fill(null));\r\n\r\n  /**\r\n   * Set Piece At\r\n   * Set a piece at a certain board position\r\n   * @param {position} Position in the board to put the new piece. Has a row and a column\r\n   * @param {piece} Piece to place at [position] in the board\r\n   * @returns A PieceObject if there is a piece at [position], null if not\r\n   */\r\n  setPieceAt = (position: PositionObject, piece: PieceObject | null) => this.board[position.row][position.column] = piece\r\n\r\n  /**\r\n   * Get Piece At\r\n   * Get the piece at a certain board position\r\n   * @param {position} Position in the board. Has a row and a column\r\n   * @returns A PieceObject if there is a piece at [position], null if not\r\n   */\r\n  getPieceAt = (position: PositionObject) => this.board[position.row][position.column]\r\n\r\n  /**\r\n   * Board to String\r\n   * Convert the current board to a string\r\n   * @returns a string representation of this.board\r\n   */\r\n  toString() {\r\n    var boardAsString: string = \"\"\r\n    this.board.map((row, rowIdx) => row.map((col, colIdx) => { \r\n      const piece = this.getPieceAt(Position(colIdx, rowIdx))\r\n      if (piece == null) {\r\n        boardAsString += \" \"\r\n      } else { \r\n        boardAsString += selectByPieceColor(piece, piece.type.toUpperCase(), piece.type)\r\n      }\r\n    }))\r\n    return boardAsString\r\n  }\r\n\r\n  /**\r\n   * Set Board Row\r\n   * Sets the pieces for a specific row on the board\r\n   * @param {rowStr} Representation of the row as a string of [BOARD_WIDTH] characters\r\n   * @param {rowNum} Row number to identify the row. From 0 to [BOARD_HEIGHT]\r\n   */\r\n  setRow = (rowStr: string, rowNum: number) => {\r\n    for (let colNum = 0; colNum < BOARD_WIDTH; colNum++) {\r\n      const pieceChar = rowStr[colNum]\r\n      if (pieceChar !== undefined) {\r\n        this.setPieceAt(Position(colNum, rowNum), charToPiece(rowStr[colNum]))\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize Board\r\n   * Set the default rows with the default chess pieces in the current board\r\n   */\r\n  initBoard() {\r\n    // Set White pieces\r\n    this.setRow(\"rnbqkbnr\", 0)\r\n    this.setRow(\"pppppppp\", 1)\r\n    // Set Black pieces\r\n    this.setRow(\"PPPPPPPP\", BOARD_HEIGHT - 2)\r\n    this.setRow(\"RNBQKBNR\", BOARD_HEIGHT - 1)\r\n  }\r\n}\r\n\r\n/**\r\n * String to Board\r\n * Convert a string to a board\r\n * If a char corresponds to a valid piece set that piece in the {newBoard}, if not set an empty Tile in the {newBoard}\r\n * @param {boardAsString} Example of a default board: \"rnbqkbnrpppppppp                                PPPPPPPPRNBQKBNR\"\r\n * @returns A new BoardObject if {boardAsString} is convertible to a board, null if not\r\n */\r\n\r\nfunction stringToBoard(boardAsString: string): BoardObject | null {\r\n  if (boardAsString.length < BOARD_WIDTH * BOARD_HEIGHT)\r\n    return null\r\n  const newBoard = new BoardObject()\r\n  for (let row = 0, currChar = 0; row < BOARD_HEIGHT; row++) {\r\n    for (let col = 0; col < BOARD_WIDTH; col++, currChar++) {\r\n      const pieceChar = boardAsString[currChar]\r\n        const piece: PieceObject | null = charToPiece(pieceChar)\r\n        // [piece] will be null if char does not correspond to a piece. Case of the \" \" representing an empty Tile\r\n        newBoard.setPieceAt(Position(col, row), piece)\r\n    }\r\n  }\r\n  return newBoard\r\n}\r\n\r\nconst B1 = new BoardObject()\r\nconst B1S = B1.toString()\r\n\r\nconst B2 = B1S.toBoard()\r\nconsole.log(B1S == B2.toString())\r\n\r\nString.prototype.toBoard = function (boardAsString: string): BoardObject | null {\r\n  if (boardAsString.length < BOARD_WIDTH * BOARD_HEIGHT)\r\n    return null\r\n  const newBoard = new BoardObject()\r\n  for (let row = 0, currChar = 0; row < BOARD_HEIGHT; row++) {\r\n    for (let col = 0; col < BOARD_WIDTH; col++, currChar++) {\r\n      const pieceChar = boardAsString[currChar]\r\n        const piece: PieceObject | null = charToPiece(pieceChar)\r\n        // [piece] will be null if char does not correspond to a piece. Case of the \" \" representing an empty Tile\r\n        newBoard.setPieceAt(Position(col, row), piece)\r\n    }\r\n  }\r\n  return newBoard\r\n}"]},"metadata":{},"sourceType":"module"}