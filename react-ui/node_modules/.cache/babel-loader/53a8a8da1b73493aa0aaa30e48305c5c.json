{"ast":null,"code":"import _createForOfIteratorHelper from\"C:\\\\Users\\\\jesus\\\\Desktop\\\\PG\\\\Personal\\\\1-Web\\\\TS\\\\OnlineChess\\\\onlinechess\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createForOfIteratorHelper.js\";import _classCallCheck from\"C:\\\\Users\\\\jesus\\\\Desktop\\\\PG\\\\Personal\\\\1-Web\\\\TS\\\\OnlineChess\\\\onlinechess\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";import _createClass from\"C:\\\\Users\\\\jesus\\\\Desktop\\\\PG\\\\Personal\\\\1-Web\\\\TS\\\\OnlineChess\\\\onlinechess\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";import{charToPiece,selectByPieceColor,PieceColor,King,Pawn,Knight,Queen,Rook,Bishop,getOpponent,pieceToChar,MoveState}from'./piece';import{Position,stringToMove,Move,moveToString}from'./position';import ERROR from'./errors';export var BOARD_WIDTH=8;export var BOARD_HEIGHT=8;/**\r\n * Board Object\r\n * Representation of a board and all it's permitted operations\r\n */export var BoardObject=/*#__PURE__*/function(){/**\r\n   * BoardObject Class contructor\r\n   * @param {initBoard} If true it will initialize this.board with pieces at default positions (true by default)\r\n   * @returns A new instance of BoardObject\r\n   */function BoardObject(){var _this=this;var initTurn=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;var initBoard=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;_classCallCheck(this,BoardObject);this.board=Array(BOARD_HEIGHT).fill(null).map(function(){return Array(BOARD_WIDTH).fill(null);});this.winner=null;this.turn=PieceColor.WHITE;this.moves=[];this.setPieceAt=function(position,piece){return _this.board[position.row][position.column]=piece;};this.getPieceAt=function(position){return _this.board[position.row][position.column];};this.findKingPosition=function(){for(var row=0;row<BOARD_HEIGHT;row++){for(var col=0;col<BOARD_WIDTH;col++){var currentPosition=Position(col,row);var currentPiece=_this.getPieceAt(currentPosition);if(currentPiece instanceof King&&_this.turn==currentPiece.color)return currentPosition;}}return null;};this.generateAllPossibleTargets=function(piecePosition){var possibleEndPositions=new Set();var piece=_this.getPieceAt(piecePosition);if(piece===null)return possibleEndPositions;for(var row=0;row<BOARD_HEIGHT;row++){for(var col=0;col<BOARD_WIDTH;col++){var currentPosition=Position(col,row);var pieceAtEndPos=_this.getPieceAt(Position(col,row));// If piece is from the same player trying to make the move don't try it\nif(pieceAtEndPos!=null&&pieceAtEndPos.color==piece.color)continue;var moveState=piece.checkMove(Move(pieceToChar(piece),piecePosition,currentPosition),_this);if(moveState==MoveState.OK){possibleEndPositions.add(currentPosition);}}}return possibleEndPositions;};this.isInCheckMate=function(){return _this.isInCheck()&&_this.generateSafeKingTargets().size===0;};this.isInCheck=function(){var kingPosition=_this.findKingPosition();if(kingPosition===null)return false;for(var row=0;row<BOARD_HEIGHT;row++){for(var col=0;col<BOARD_WIDTH;col++){var piecePosition=Position(col,row);var piece=_this.getPieceAt(piecePosition);if(piece!=null&&piece.color==getOpponent(_this.turn)){var possibleMovesForPiece=_this.generateAllPossibleTargets(piecePosition);possibleMovesForPiece.forEach(function(move){if(move.column===kingPosition.column&&move.row===kingPosition.row)return true;});}}}return false;};this.isPromotionMove=function(moveAsString){var move=stringToMove(moveAsString);var piece=_this.getPieceAt(move.start);if(!(piece instanceof Pawn)){return false;}if(_this.turn==PieceColor.WHITE&&move.end.row==0){return true;}if(_this.turn==PieceColor.BLACK&&move.end.row==7){return true;}return false;};this.makeMove=function(moveAsString){var move=stringToMove(moveAsString);var maybePromotionPiece=charToPiece(selectByPieceColor(_this.turn,move.pieceChar.toUpperCase(),move.pieceChar.toLowerCase()));var piece=_this.getPieceAt(move.start);var capturePiece=_this.getPieceAt(move.end);if(_this.winner!=null){throw ERROR.ALREADY_OVER;}if(piece===null)throw ERROR.NO_PIECE_AT_START_POSITION;/*\r\n    if (!(piece instanceof King) && this.isInCheck()) {\r\n      throw ERROR.KING_IN_CHECK\r\n    }\r\n    */var isPromotion=maybePromotionPiece.toString().toUpperCase()!=piece.toString().toUpperCase();if(// When true means Promotion\nisPromotion&&// Check if it is a Pawn and if it's not a game winning move\npiece instanceof Pawn&&!(capturePiece instanceof King)&&(// Check if it's valid promotion piece\nmaybePromotionPiece instanceof Knight||maybePromotionPiece instanceof Queen||maybePromotionPiece instanceof Bishop||maybePromotionPiece instanceof Rook)){// Transform pawn\n_this.setPieceAt(move.end,maybePromotionPiece);_this.setPieceAt(move.start,null);}else{_this.setPieceAt(move.end,piece);_this.setPieceAt(move.start,null);}if(piece instanceof Pawn)piece.hasMoved=true;// If this move makes the other player's King be in check and with nowhere to go tell board he won\nif(_this.isInCheck()&&_this.generateSafeKingTargets().size===0)_this.winner=getOpponent(_this.turn);_this.turn=getOpponent(_this.turn);_this.updateWinner();_this.moves.push(move);};this.setRow=function(rowStr,rowNum){for(var colNum=0;colNum<BOARD_WIDTH;colNum++){var pieceChar=rowStr[colNum];if(pieceChar!==undefined){_this.setPieceAt(Position(colNum,rowNum),charToPiece(rowStr[colNum]));}}};if(initBoard){this.initBoard();}if(initTurn!=null){this.turn=initTurn;}}_createClass(BoardObject,[{key:\"stringMoves\",value:function stringMoves(){return this.moves.map(function(move){return moveToString(move);});}/**\r\n   * Initialize Board\r\n   * Set the default rows with the default chess pieces in the current board\r\n   */},{key:\"initBoard\",value:function initBoard(){// Set White pieces\nthis.setRow(\"rnbqkbnr\",0);this.setRow(\"pppppppp\",1);// Set Black pieces\nthis.setRow(\"PPPPPPPP\",BOARD_HEIGHT-2);this.setRow(\"RNBQKBNR\",BOARD_HEIGHT-1);}},{key:\"generateSafeKingTargets\",value:function generateSafeKingTargets(){var _this2=this;var kingPosition=this.findKingPosition();if(kingPosition==null)return new Set();// Initial King Targets (Mutable set to remove in the end)\n// Could also return a new Set with the exclusion of both Sets\nvar possibleKingTargets=this.generateAllPossibleTargets(kingPosition);// Set that will store the suicide positions for the King\nvar collisions=new Set();this.setPieceAt(kingPosition,null);possibleKingTargets.forEach(function(target){// Remove King from the board to corretly make the predictions\n// For all the board pieces\nfor(var row=0;row<BOARD_HEIGHT;row++){var _loop=function _loop(col){var enemyPosition=Position(col,row);var enemyPiece=_this2.getPieceAt(enemyPosition);var targetPiece=_this2.getPieceAt(target);_this2.setPieceAt(target,null);/*\r\n           If Enemy Piece Generate it's possible moves and those that match the\r\n           king targets are added to the \"collisions\" Set\r\n           */if(enemyPiece!=null&&enemyPiece.color!=_this2.turn){var possibleEnemyTargets=_this2.generateAllPossibleTargets(enemyPosition);/*\r\n             If piece is a pawn it can only eat in diagonal so moving forward is not a threat to King\r\n             */if(enemyPiece instanceof Pawn){var direction=selectByPieceColor(_this2.turn,-1,1);// Add diagonals as Pawn targets\nif(enemyPosition.column<BOARD_WIDTH-1)possibleEnemyTargets.add(Position(enemyPosition.column+1,enemyPosition.row-direction));if(enemyPosition.column>0)possibleEnemyTargets.add(Position(enemyPosition.column-1,enemyPosition.row-direction));// Remove targets in which pawn moves vertically\npossibleEnemyTargets.forEach(function(enemyTarget){if(enemyTarget.column==enemyPosition.column)possibleEnemyTargets.delete(enemyTarget);});}// Remove suicide targets\npossibleEnemyTargets.forEach(function(enemyTarget){possibleKingTargets.forEach(function(target){if(enemyTarget.column===target.column&&enemyTarget.row===target.row)collisions.add(enemyTarget);});});}// Put target piece back again\n_this2.setPieceAt(target,targetPiece);};for(var col=0;col<BOARD_WIDTH;col++){_loop(col);}}});// Put King back to the board after predicting enemy targets\nthis.setPieceAt(kingPosition,new King(this.turn));/*\r\n     Remove from the King targets the suicide positions\r\n     */possibleKingTargets.forEach(function(kingPos){collisions.forEach(function(collision){if(collision.column===kingPos.column&&collision.row===kingPos.row)possibleKingTargets.delete(kingPos);});});return possibleKingTargets;}},{key:\"updateWinner\",value:function updateWinner(){if(this.findKingPosition()==null){this.winner=getOpponent(this.turn);}var backupTurn=this.turn;this.turn=getOpponent(this.turn);if(this.findKingPosition()==null){this.winner=getOpponent(this.turn);}this.turn=backupTurn;}/**\r\n   * Board to String\r\n   * Convert the current board to a string\r\n   * @returns a string representation of this.board\r\n   */},{key:\"toString\",value:function toString(){var _this3=this;var boardAsString=\"\";this.board.map(function(row,rowIdx){return row.map(function(col,colIdx){var piece=_this3.getPieceAt(Position(colIdx,rowIdx));if(piece==null){boardAsString+=\" \";}else{boardAsString+=selectByPieceColor(piece.color,piece.toString().toUpperCase(),piece.toString());}});});return boardAsString;}/**\r\n   * Set Board Row\r\n   * Sets the pieces for a specific row on the board\r\n   * @param {rowStr} Representation of the row as a string of [BOARD_WIDTH] characters\r\n   * @param {rowNum} Row number to identify the row. From 0 to [BOARD_HEIGHT]\r\n   */}],[{key:\"fromMoves\",value:function fromMoves(moves){var baseBoard=new BoardObject();var _iterator=_createForOfIteratorHelper(moves),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var move=_step.value;baseBoard.makeMove(move);}}catch(err){_iterator.e(err);}finally{_iterator.f();}return baseBoard;}/**\r\n   * Set Piece At\r\n   * Set a piece at a certain board position\r\n   * @param {position} Position in the board to put the new piece. Has a row and a column\r\n   * @param {piece} Piece to place at [position] in the board\r\n   * @returns A Piece if there is a piece at [position], null if not\r\n   */}]);return BoardObject;}();/**\r\n * String to Board\r\n * Convert a string to a board\r\n * If a char corresponds to a valid piece set that piece in the {newBoard}, if not set an empty Tile in the {newBoard}\r\n * @param {boardAsString} Example of a default board: \"rnbqkbnrpppppppp                                PPPPPPPPRNBQKBNR\"\r\n * @returns A new BoardObject if {boardAsString} is convertible to a board, null if not\r\n */ /* export function stringToBoard(boardAsString: string, initTurn: PieceColor | null = null): BoardObject {\r\n  if (boardAsString.length != BOARD_WIDTH * BOARD_HEIGHT)\r\n    throw ERROR.BAD_BOARD_STRING\r\n\r\n  var blackHasKing = false\r\n  var whiteHasKing = false\r\n\r\n  const newBoard = new BoardObject(initTurn, false)\r\n  for (let row = 0, currChar = 0; row < BOARD_HEIGHT; row++) {\r\n    for (let col = 0; col < BOARD_WIDTH; col++, currChar++) {\r\n      const pieceChar = boardAsString[currChar]\r\n      const piece: Piece | null = charToPiece(pieceChar)\r\n      if (piece instanceof King) {\r\n        if (piece.color == PieceColor.WHITE) {\r\n          whiteHasKing = true\r\n        } else if (piece.color == PieceColor.BLACK) {\r\n          blackHasKing = true\r\n        }\r\n      }\r\n      // [piece] will be null if char does not correspond to a piece. Case of the \" \" representing an empty Tile\r\n      newBoard.setPieceAt(Position(col, row), piece)\r\n    }\r\n  }\r\n  if (!blackHasKing)\r\n    newBoard.winner = PieceColor.WHITE\r\n  if (!whiteHasKing)\r\n    newBoard.winner = PieceColor.BLACK\r\n  return newBoard\r\n}\r\n */","map":{"version":3,"sources":["C:/Users/jesus/Desktop/PG/Personal/1-Web/TS/OnlineChess/onlinechess/src/domain/board.ts"],"names":["charToPiece","selectByPieceColor","PieceColor","King","Pawn","Knight","Queen","Rook","Bishop","getOpponent","pieceToChar","MoveState","Position","stringToMove","Move","moveToString","ERROR","BOARD_WIDTH","BOARD_HEIGHT","BoardObject","initTurn","initBoard","board","Array","fill","map","winner","turn","WHITE","moves","setPieceAt","position","piece","row","column","getPieceAt","findKingPosition","col","currentPosition","currentPiece","color","generateAllPossibleTargets","piecePosition","possibleEndPositions","Set","pieceAtEndPos","moveState","checkMove","OK","add","isInCheckMate","isInCheck","generateSafeKingTargets","size","kingPosition","possibleMovesForPiece","forEach","move","isPromotionMove","moveAsString","start","end","BLACK","makeMove","maybePromotionPiece","pieceChar","toUpperCase","toLowerCase","capturePiece","ALREADY_OVER","NO_PIECE_AT_START_POSITION","isPromotion","toString","hasMoved","updateWinner","push","setRow","rowStr","rowNum","colNum","undefined","possibleKingTargets","collisions","target","enemyPosition","enemyPiece","targetPiece","possibleEnemyTargets","direction","enemyTarget","delete","kingPos","collision","backupTurn","boardAsString","rowIdx","colIdx","baseBoard"],"mappings":"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","sourcesContent":["import {\r\n  Piece,\r\n  charToPiece,\r\n  selectByPieceColor,\r\n  PieceColor,\r\n  King,\r\n  Pawn,\r\n  Knight,\r\n  Queen,\r\n  Rook,\r\n  Bishop,\r\n  getOpponent,\r\n  pieceToChar,\r\n  MoveState\r\n} from './piece'\r\nimport { PositionObject, Position, stringToMove, Move, MoveObject, moveToString } from './position'\r\nimport ERROR from './errors'\r\n\r\nexport const BOARD_WIDTH = 8;\r\nexport const BOARD_HEIGHT = 8;\r\n\r\n\r\n/**\r\n * Board Object\r\n * Representation of a board and all it's permitted operations\r\n */\r\nexport class BoardObject {\r\n\r\n  board: Array<Array<Piece | null>> = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(null));\r\n  winner: PieceColor | null = null\r\n  turn: PieceColor = PieceColor.WHITE\r\n  moves: MoveObject[] = []\r\n\r\n  /**\r\n   * BoardObject Class contructor\r\n   * @param {initBoard} If true it will initialize this.board with pieces at default positions (true by default)\r\n   * @returns A new instance of BoardObject\r\n   */\r\n  constructor(initTurn: PieceColor | null = null, initBoard: boolean = true) {\r\n    if (initBoard) {\r\n      this.initBoard()\r\n    }\r\n    if (initTurn != null) {\r\n      this.turn = initTurn\r\n    }\r\n  }\r\n\r\n  stringMoves() {\r\n    return this.moves.map(move => moveToString(move))\r\n  }\r\n\r\n  /**\r\n   * Initialize Board\r\n   * Set the default rows with the default chess pieces in the current board\r\n   */\r\n  initBoard() {\r\n    // Set White pieces\r\n    this.setRow(\"rnbqkbnr\", 0)\r\n    this.setRow(\"pppppppp\", 1)\r\n    // Set Black pieces\r\n    this.setRow(\"PPPPPPPP\", BOARD_HEIGHT - 2)\r\n    this.setRow(\"RNBQKBNR\", BOARD_HEIGHT - 1)\r\n  }\r\n\r\n  static fromMoves(moves: string[]) {\r\n    const baseBoard = new BoardObject()\r\n    for (const move of moves) {\r\n      baseBoard.makeMove(move)\r\n    }\r\n    return baseBoard\r\n  }\r\n\r\n  /**\r\n   * Set Piece At\r\n   * Set a piece at a certain board position\r\n   * @param {position} Position in the board to put the new piece. Has a row and a column\r\n   * @param {piece} Piece to place at [position] in the board\r\n   * @returns A Piece if there is a piece at [position], null if not\r\n   */\r\n  setPieceAt = (position: PositionObject, piece: Piece | null) => this.board[position.row][position.column] = piece\r\n\r\n  /**\r\n   * Get Piece At\r\n   * Get the piece at a certain board position\r\n   * @param {position} Position in the board. Has a row and a column\r\n   * @returns A Piece if there is a piece at [position], null if not\r\n   */\r\n  getPieceAt = (position: PositionObject): Piece | null => this.board[position.row][position.column]\r\n\r\n  findKingPosition = (): PositionObject | null => {\r\n    for (let row = 0; row < BOARD_HEIGHT; row++) {\r\n      for (let col = 0; col < BOARD_WIDTH; col++) {\r\n        const currentPosition = Position(col, row)\r\n        const currentPiece = this.getPieceAt(currentPosition)\r\n\r\n        if (currentPiece instanceof King && this.turn == currentPiece.color)\r\n          return currentPosition\r\n      }\r\n    }\r\n    return null\r\n  }\r\n\r\n  generateAllPossibleTargets = (piecePosition: PositionObject): Set<PositionObject> => {\r\n    const possibleEndPositions = new Set<PositionObject>()\r\n    const piece = this.getPieceAt(piecePosition)\r\n    if (piece === null)\r\n      return possibleEndPositions\r\n\r\n    for (let row = 0; row < BOARD_HEIGHT; row++) {\r\n      for (let col = 0; col < BOARD_WIDTH; col++) {\r\n        const currentPosition = Position(col, row)\r\n        const pieceAtEndPos = this.getPieceAt(Position(col, row))\r\n\r\n        // If piece is from the same player trying to make the move don't try it\r\n        if (pieceAtEndPos != null && pieceAtEndPos.color == piece.color)\r\n          continue\r\n\r\n        const moveState = piece.checkMove(Move(pieceToChar(piece), piecePosition, currentPosition), this)\r\n\r\n        if (moveState == MoveState.OK) {\r\n          possibleEndPositions.add(currentPosition)\r\n        }\r\n      }\r\n    }\r\n    return possibleEndPositions\r\n  }\r\n\r\n  generateSafeKingTargets(): Set<PositionObject> {\r\n    const kingPosition = this.findKingPosition()\r\n\r\n    if (kingPosition == null)\r\n      return new Set<PositionObject>()\r\n\r\n    // Initial King Targets (Mutable set to remove in the end)\r\n    // Could also return a new Set with the exclusion of both Sets\r\n    const possibleKingTargets = this.generateAllPossibleTargets(kingPosition)\r\n\r\n    // Set that will store the suicide positions for the King\r\n    const collisions = new Set<PositionObject>()\r\n\r\n    this.setPieceAt(kingPosition, null)\r\n\r\n    possibleKingTargets.forEach((target) => {\r\n      // Remove King from the board to corretly make the predictions\r\n      // For all the board pieces\r\n      for (let row = 0; row < BOARD_HEIGHT; row++) {\r\n        for (let col = 0; col < BOARD_WIDTH; col++) {\r\n          const enemyPosition = Position(col, row)\r\n          const enemyPiece = this.getPieceAt(enemyPosition)\r\n\r\n          const targetPiece = this.getPieceAt(target)\r\n          this.setPieceAt(target, null)\r\n          /*\r\n           If Enemy Piece Generate it's possible moves and those that match the\r\n           king targets are added to the \"collisions\" Set\r\n           */\r\n          if (enemyPiece != null && enemyPiece.color != this.turn) {\r\n            const possibleEnemyTargets = this.generateAllPossibleTargets(enemyPosition)\r\n            /*\r\n             If piece is a pawn it can only eat in diagonal so moving forward is not a threat to King\r\n             */\r\n            if (enemyPiece instanceof Pawn) {\r\n              const direction = selectByPieceColor(this.turn, -1, 1)\r\n              // Add diagonals as Pawn targets\r\n              if (enemyPosition.column < BOARD_WIDTH - 1)\r\n                possibleEnemyTargets.add(Position(enemyPosition.column + 1, enemyPosition.row - direction))\r\n              if (enemyPosition.column > 0)\r\n                possibleEnemyTargets.add(Position(enemyPosition.column - 1, enemyPosition.row - direction))\r\n\r\n              // Remove targets in which pawn moves vertically\r\n              possibleEnemyTargets.forEach((enemyTarget: PositionObject) => {\r\n                if (enemyTarget.column == enemyPosition.column)\r\n                  possibleEnemyTargets.delete(enemyTarget)\r\n              })\r\n            }\r\n            // Remove suicide targets\r\n            possibleEnemyTargets.forEach((enemyTarget) => {\r\n              possibleKingTargets.forEach(target => {\r\n                if (enemyTarget.column === target.column && enemyTarget.row === target.row)\r\n                  collisions.add(enemyTarget)\r\n              })\r\n            })\r\n          }\r\n          // Put target piece back again\r\n          this.setPieceAt(target, targetPiece)\r\n        }\r\n      }\r\n    })\r\n\r\n    // Put King back to the board after predicting enemy targets\r\n    this.setPieceAt(kingPosition, new King(this.turn))\r\n    /*\r\n     Remove from the King targets the suicide positions\r\n     */\r\n    possibleKingTargets.forEach((kingPos: PositionObject) => {\r\n      collisions.forEach(collision => {\r\n        if (collision.column === kingPos.column && collision.row === kingPos.row)\r\n          possibleKingTargets.delete(kingPos)\r\n      })\r\n    })\r\n    return possibleKingTargets\r\n  }\r\n\r\n  isInCheckMate = () => this.isInCheck() && (this.generateSafeKingTargets().size === 0)\r\n\r\n  isInCheck = (): boolean => {\r\n    const kingPosition = this.findKingPosition()\r\n    if (kingPosition === null) return false\r\n\r\n    for (let row = 0; row < BOARD_HEIGHT; row++) {\r\n      for (let col = 0; col < BOARD_WIDTH; col++) {\r\n        const piecePosition = Position(col, row)\r\n        const piece = this.getPieceAt(piecePosition)\r\n        if (piece != null && piece.color == getOpponent(this.turn)) {\r\n          const possibleMovesForPiece = this.generateAllPossibleTargets(piecePosition)\r\n          possibleMovesForPiece.forEach(move => {\r\n            if (move.column === kingPosition.column && move.row === kingPosition.row)\r\n              return true\r\n          })\r\n        }\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  isPromotionMove = (moveAsString: string) => {\r\n    const move = stringToMove(moveAsString)\r\n    const piece = this.getPieceAt(move.start)\r\n    if (!(piece instanceof Pawn)) {\r\n      return false\r\n    }\r\n    if (this.turn == PieceColor.WHITE && move.end.row == 0) {\r\n      return true\r\n    }\r\n    if (this.turn == PieceColor.BLACK && move.end.row == 7) {\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  makeMove = (moveAsString: string) => {\r\n    const move = stringToMove(moveAsString)\r\n    const maybePromotionPiece = charToPiece(selectByPieceColor(this.turn, move.pieceChar.toUpperCase(), move.pieceChar.toLowerCase()))!!\r\n    const piece = this.getPieceAt(move.start)\r\n    const capturePiece = this.getPieceAt(move.end)\r\n\r\n    if (this.winner != null) {\r\n      throw ERROR.ALREADY_OVER\r\n    }\r\n\r\n    if (piece === null) throw ERROR.NO_PIECE_AT_START_POSITION\r\n\r\n    /*\r\n    if (!(piece instanceof King) && this.isInCheck()) {\r\n      throw ERROR.KING_IN_CHECK\r\n    }\r\n    */\r\n\r\n    const isPromotion = maybePromotionPiece.toString().toUpperCase() != piece.toString().toUpperCase()\r\n\r\n    if (\r\n      // When true means Promotion\r\n      isPromotion &&\r\n      // Check if it is a Pawn and if it's not a game winning move\r\n      (piece instanceof Pawn) && !(capturePiece instanceof King) &&\r\n      // Check if it's valid promotion piece\r\n      (maybePromotionPiece instanceof Knight || maybePromotionPiece instanceof Queen || maybePromotionPiece instanceof Bishop || maybePromotionPiece instanceof Rook)\r\n    ) {\r\n      // Transform pawn\r\n      this.setPieceAt(move.end, maybePromotionPiece)\r\n      this.setPieceAt(move.start, null)\r\n    } else {\r\n      this.setPieceAt(move.end, piece)\r\n      this.setPieceAt(move.start, null)\r\n    }\r\n\r\n    if (piece instanceof Pawn)\r\n      piece.hasMoved = true\r\n\r\n    // If this move makes the other player's King be in check and with nowhere to go tell board he won\r\n    if (this.isInCheck() && this.generateSafeKingTargets().size === 0)\r\n      this.winner = getOpponent(this.turn)\r\n\r\n    this.turn = getOpponent(this.turn)\r\n\r\n    this.updateWinner()\r\n    this.moves.push(move)\r\n  }\r\n\r\n  updateWinner() {\r\n    if (this.findKingPosition() == null) {\r\n      this.winner = getOpponent(this.turn)\r\n    }\r\n    const backupTurn = this.turn\r\n    this.turn = getOpponent(this.turn)\r\n\r\n    if (this.findKingPosition() == null) {\r\n      this.winner = getOpponent(this.turn)\r\n    }\r\n    this.turn = backupTurn\r\n  }\r\n\r\n  /**\r\n   * Board to String\r\n   * Convert the current board to a string\r\n   * @returns a string representation of this.board\r\n   */\r\n  toString() {\r\n    var boardAsString: string = \"\"\r\n    this.board.map((row, rowIdx) => row.map((col, colIdx) => {\r\n      const piece = this.getPieceAt(Position(colIdx, rowIdx))\r\n      if (piece == null) {\r\n        boardAsString += \" \"\r\n      } else {\r\n        boardAsString += selectByPieceColor(piece.color, piece.toString().toUpperCase(), piece.toString())\r\n      }\r\n    }))\r\n    return boardAsString\r\n  }\r\n\r\n  /**\r\n   * Set Board Row\r\n   * Sets the pieces for a specific row on the board\r\n   * @param {rowStr} Representation of the row as a string of [BOARD_WIDTH] characters\r\n   * @param {rowNum} Row number to identify the row. From 0 to [BOARD_HEIGHT]\r\n   */\r\n  setRow = (rowStr: string, rowNum: number) => {\r\n    for (let colNum = 0; colNum < BOARD_WIDTH; colNum++) {\r\n      const pieceChar = rowStr[colNum]\r\n      if (pieceChar !== undefined) {\r\n        this.setPieceAt(Position(colNum, rowNum), charToPiece(rowStr[colNum])!!)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * String to Board\r\n * Convert a string to a board\r\n * If a char corresponds to a valid piece set that piece in the {newBoard}, if not set an empty Tile in the {newBoard}\r\n * @param {boardAsString} Example of a default board: \"rnbqkbnrpppppppp                                PPPPPPPPRNBQKBNR\"\r\n * @returns A new BoardObject if {boardAsString} is convertible to a board, null if not\r\n */\r\n/* export function stringToBoard(boardAsString: string, initTurn: PieceColor | null = null): BoardObject {\r\n  if (boardAsString.length != BOARD_WIDTH * BOARD_HEIGHT)\r\n    throw ERROR.BAD_BOARD_STRING\r\n\r\n  var blackHasKing = false\r\n  var whiteHasKing = false\r\n\r\n  const newBoard = new BoardObject(initTurn, false)\r\n  for (let row = 0, currChar = 0; row < BOARD_HEIGHT; row++) {\r\n    for (let col = 0; col < BOARD_WIDTH; col++, currChar++) {\r\n      const pieceChar = boardAsString[currChar]\r\n      const piece: Piece | null = charToPiece(pieceChar)\r\n      if (piece instanceof King) {\r\n        if (piece.color == PieceColor.WHITE) {\r\n          whiteHasKing = true\r\n        } else if (piece.color == PieceColor.BLACK) {\r\n          blackHasKing = true\r\n        }\r\n      }\r\n      // [piece] will be null if char does not correspond to a piece. Case of the \" \" representing an empty Tile\r\n      newBoard.setPieceAt(Position(col, row), piece)\r\n    }\r\n  }\r\n  if (!blackHasKing)\r\n    newBoard.winner = PieceColor.WHITE\r\n  if (!whiteHasKing)\r\n    newBoard.winner = PieceColor.BLACK\r\n  return newBoard\r\n}\r\n */"]},"metadata":{},"sourceType":"module"}