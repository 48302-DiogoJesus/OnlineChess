{"ast":null,"code":"import { Position } from \"./position\";\n/**\r\n * Piece Object\r\n * Schema of a PieceObject\r\n * @property {color} Color of the piece: Black or White\r\n * @property {type} Piece type: Pawn, Rook, Knight, King, Queen, Bishop\r\n\r\n export interface PieceObject {\r\n    color: PieceColor,\r\n    type: PieceType\r\n}\r\n */\n\n/**\r\n * Piece Color\r\n */\n\nexport let PieceColor;\n\n(function (PieceColor) {\n  PieceColor[\"BLACK\"] = \"b\";\n  PieceColor[\"WHITE\"] = \"w\";\n})(PieceColor || (PieceColor = {}));\n\nexport function getOpponent(pieceColor) {\n  return pieceColor === PieceColor.BLACK ? PieceColor.WHITE : PieceColor.BLACK;\n}\n/**\r\n * Select by PieceColor\r\n * @param {piece} PieceObject to evaluate the color from\r\n * @param {ifWhite} Return this value if [piece] is white\r\n * @param {ifBlack} Return this value if [piece] is black\r\n * @returns {ifWhite} if {piece} is white, {ifBlack} if {ifWhite} is black\r\n */\n\nexport function selectByPieceColor(pieceColor, ifWhite, ifBlack) {\n  return pieceColor === PieceColor.WHITE ? ifWhite : ifBlack;\n}\n/**\r\n * Piece Type\r\n */\n\nexport let PieceType;\n\n(function (PieceType) {\n  PieceType[\"PAWN\"] = \"p\";\n  PieceType[\"KING\"] = \"k\";\n  PieceType[\"QUEEN\"] = \"q\";\n  PieceType[\"ROOK\"] = \"r\";\n  PieceType[\"KNIGHT\"] = \"n\";\n  PieceType[\"BISHOP\"] = \"b\";\n})(PieceType || (PieceType = {}));\n\nvar Direction;\n\n(function (Direction) {\n  Direction[Direction[\"UP\"] = 0] = \"UP\";\n  Direction[Direction[\"DOWN\"] = 1] = \"DOWN\";\n  Direction[Direction[\"LEFT\"] = 2] = \"LEFT\";\n  Direction[Direction[\"RIGHT\"] = 3] = \"RIGHT\";\n})(Direction || (Direction = {}));\n\nexport let MoveState;\n\n(function (MoveState) {\n  MoveState[MoveState[\"OK\"] = 0] = \"OK\";\n  MoveState[MoveState[\"NO_CHANGE\"] = 1] = \"NO_CHANGE\";\n  MoveState[MoveState[\"PATH_INVALID\"] = 2] = \"PATH_INVALID\";\n  MoveState[MoveState[\"PATH_BLOCKED\"] = 3] = \"PATH_BLOCKED\";\n  MoveState[MoveState[\"DEST_BLOCKED\"] = 4] = \"DEST_BLOCKED\";\n})(MoveState || (MoveState = {}));\n\nfunction calculateDirection(move) {\n  const result = new Set();\n  if (move.end.row < move.start.row) result.add(Direction.UP);else if (move.end.row > move.start.row) result.add(Direction.DOWN);\n  if (move.end.column < move.start.column) result.add(Direction.LEFT);else if (move.end.column > move.start.column) result.add(Direction.RIGHT);\n  return result;\n}\n\nexport class Piece {\n  constructor() {\n    this.color = void 0;\n    this.validPath = void 0;\n\n    this.pathBlocked = (move, board) => {\n      const direction = calculateDirection(move);\n      const current = Position(move.start.column, move.start.row);\n\n      while (true) {\n        if (direction.has(Direction.UP)) current.row--;\n        if (direction.has(Direction.DOWN)) current.row++;\n        if (direction.has(Direction.LEFT)) current.column--;\n        if (direction.has(Direction.RIGHT)) current.column++;\n\n        if (current.column == move.end.column && current.row == move.end.row) {\n          return false;\n        }\n\n        if (board.getPieceAt(current) !== null) return true;\n      }\n    };\n\n    this.destinationBlocked = (move, board) => {\n      const other = board.getPieceAt(move.end);\n      if (other == null || other == undefined) return false;\n      return other.color == this.color;\n    };\n  }\n\n  checkMove(move, board) {\n    if (move.start == move.end) return MoveState.NO_CHANGE;\n    if (!this.validPath(move, board)) return MoveState.PATH_INVALID;\n    if (!(board.getPieceAt(move.start) instanceof Knight) && this.pathBlocked(move, board)) return MoveState.PATH_BLOCKED;\n    if (this.destinationBlocked(move, board)) return MoveState.DEST_BLOCKED;\n    return MoveState.OK;\n  }\n\n}\nexport class King extends Piece {\n  constructor(pieceColor) {\n    super();\n    this.color = void 0;\n\n    this.validPath = (move, board) => {\n      const absoluteRow = Math.abs(move.start.row - move.end.row);\n      const absoluteColumn = Math.abs(move.start.column - move.end.column);\n      return absoluteRow <= 1 && absoluteColumn <= 1;\n    };\n\n    this.toString = () => pieceToChar(this);\n\n    this.color = pieceColor;\n  }\n\n}\nexport class Rook extends Piece {\n  constructor(pieceColor) {\n    super();\n    this.color = void 0;\n\n    this.validPath = (move, board) => {\n      return move.start.column == move.end.column || move.start.row == move.end.row;\n    };\n\n    this.toString = () => pieceToChar(this);\n\n    this.color = pieceColor;\n  }\n\n}\nexport class Bishop extends Piece {\n  constructor(pieceColor) {\n    super();\n    this.color = void 0;\n\n    this.validPath = (move, board) => {\n      return Math.abs(move.start.column - move.end.column) == Math.abs(move.start.row - move.end.row);\n    };\n\n    this.toString = () => pieceToChar(this);\n\n    this.color = pieceColor;\n  }\n\n}\nexport class Queen extends Piece {\n  constructor(pieceColor) {\n    super();\n    this.color = void 0;\n\n    this.validPath = (move, board) => {\n      return move.start.row == move.end.row || move.start.column == move.end.column || Math.abs(move.start.row - move.end.row) == Math.abs(move.start.column - move.end.column);\n    };\n\n    this.toString = () => pieceToChar(this);\n\n    this.color = pieceColor;\n  }\n\n}\nexport class Knight extends Piece {\n  constructor(pieceColor) {\n    super();\n    this.color = void 0;\n\n    this.validPath = (move, board) => {\n      return Math.abs(move.end.column - move.start.column) == 2 && Math.abs(move.end.row - move.start.row) == 1 || Math.abs(move.end.column - move.start.column) == 1 && Math.abs(move.end.row - move.start.row) == 2;\n    };\n\n    this.toString = () => pieceToChar(this);\n\n    this.color = pieceColor;\n  }\n\n}\nexport class Pawn extends Piece {\n  constructor(pieceColor) {\n    super();\n    this.hasMoved = false;\n    this.color = void 0;\n\n    this.validPath = (move, board) => {\n      const steps = this.hasMoved ? 1 : 2;\n      const direction = selectByPieceColor(this.color, -1, 1);\n      return (// Vertical movement\n        move.start.column == move.end.column && (direction == -1 ? board.getPieceAt(move.end) == null && move.start.row > move.end.row && move.start.row - move.end.row <= steps : board.getPieceAt(move.end) == null && move.end.row > move.start.row && move.end.row - move.start.row <= steps) || // Horizontal movement\n        Math.abs(move.start.column - move.end.column) == 1 && move.end.row - move.start.row == direction && board.getPieceAt(move.end) != null\n      );\n    };\n\n    this.toString = () => pieceToChar(this);\n\n    this.color = pieceColor;\n  }\n\n}\nconst charPieceMap = {\n  'K': King,\n  'R': Rook,\n  'B': Bishop,\n  'Q': Queen,\n  'N': Knight,\n  'P': Pawn\n};\nconst charPieces = ['K', 'R', 'B', 'Q', 'N', 'P'];\nexport const charToPiece = char => {\n  for (const entry of Object.entries(charPieceMap)) {\n    const pieceChar = entry[0];\n    const pieceClass = entry[1];\n\n    if (pieceChar === char.toUpperCase()) {\n      // console.log(\"FOUND:\", pieceChar, pieceClass.name)\n      const color = char === char.toUpperCase() ? PieceColor.WHITE : PieceColor.BLACK;\n      const newPiece = new pieceClass(color);\n      console.log(newPiece);\n      return newPiece;\n    }\n  }\n\n  return null;\n};\nexport const pieceToChar = piece => {\n  let pieceChar;\n\n  if (piece instanceof Knight) {\n    pieceChar = 'N';\n  } else {\n    pieceChar = piece.constructor.name[0];\n  }\n\n  return selectByPieceColor(piece.color, pieceChar.toUpperCase(), pieceChar.toLowerCase());\n};","map":{"version":3,"sources":["C:/Users/jesus/Desktop/PG/Personal/1-Web/TS/OnlineChess/chessbackend/react-ui/src/domain/piece.ts"],"names":["Position","PieceColor","getOpponent","pieceColor","BLACK","WHITE","selectByPieceColor","ifWhite","ifBlack","PieceType","Direction","MoveState","calculateDirection","move","result","Set","end","row","start","add","UP","DOWN","column","LEFT","RIGHT","Piece","color","validPath","pathBlocked","board","direction","current","has","getPieceAt","destinationBlocked","other","undefined","checkMove","NO_CHANGE","PATH_INVALID","Knight","PATH_BLOCKED","DEST_BLOCKED","OK","King","constructor","absoluteRow","Math","abs","absoluteColumn","toString","pieceToChar","Rook","Bishop","Queen","Pawn","hasMoved","steps","charPieceMap","charPieces","charToPiece","char","entry","Object","entries","pieceChar","pieceClass","toUpperCase","newPiece","console","log","piece","name","toLowerCase"],"mappings":"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","sourcesContent":["import { BoardObject } from \"./board\"\r\nimport { MoveObject, Position } from \"./position\"\r\n\r\n/**\r\n * Piece Object\r\n * Schema of a PieceObject\r\n * @property {color} Color of the piece: Black or White\r\n * @property {type} Piece type: Pawn, Rook, Knight, King, Queen, Bishop\r\n\r\n export interface PieceObject {\r\n    color: PieceColor,\r\n    type: PieceType\r\n}\r\n */\r\n/**\r\n * Piece Color\r\n */\r\n\r\nexport enum PieceColor {\r\n    BLACK = 'b',\r\n    WHITE = 'w',\r\n}\r\n\r\nexport function getOpponent(pieceColor: PieceColor) {\r\n    return pieceColor === PieceColor.BLACK ? PieceColor.WHITE : PieceColor.BLACK;\r\n}\r\n\r\n/**\r\n * Select by PieceColor\r\n * @param {piece} PieceObject to evaluate the color from\r\n * @param {ifWhite} Return this value if [piece] is white\r\n * @param {ifBlack} Return this value if [piece] is black\r\n * @returns {ifWhite} if {piece} is white, {ifBlack} if {ifWhite} is black\r\n */\r\nexport function selectByPieceColor<T>(pieceColor: PieceColor, ifWhite: T, ifBlack: T): T {\r\n    return pieceColor === PieceColor.WHITE ? ifWhite : ifBlack\r\n}\r\n\r\n/**\r\n * Piece Type\r\n */\r\nexport enum PieceType {\r\n    PAWN = 'p',\r\n    KING = 'k',\r\n    QUEEN = 'q',\r\n    ROOK = 'r',\r\n    KNIGHT = 'n',\r\n    BISHOP = 'b'\r\n}\r\n\r\nenum Direction { UP, DOWN, LEFT, RIGHT }\r\n\r\nexport enum MoveState { OK, NO_CHANGE, PATH_INVALID, PATH_BLOCKED, DEST_BLOCKED }\r\n\r\nfunction calculateDirection(move: MoveObject) {\r\n    const result = new Set()\r\n\r\n    if (move.end.row < move.start.row)\r\n        result.add(Direction.UP)\r\n    else if (move.end.row > move.start.row)\r\n        result.add(Direction.DOWN)\r\n\r\n    if (move.end.column < move.start.column)\r\n        result.add(Direction.LEFT)\r\n    else if (move.end.column > move.start.column)\r\n        result.add(Direction.RIGHT)\r\n\r\n    return result\r\n}\r\n\r\nexport abstract class Piece {\r\n    abstract color: PieceColor;\r\n    abstract validPath: (move: MoveObject, board: BoardObject) => boolean;\r\n    pathBlocked = (move: MoveObject, board: BoardObject): boolean => {\r\n        const direction = calculateDirection(move)\r\n        const current = Position(move.start.column, move.start.row)\r\n\r\n        while (true) {\r\n            if (direction.has(Direction.UP))\r\n                current.row--\r\n            if (direction.has(Direction.DOWN))\r\n                current.row++\r\n            if (direction.has(Direction.LEFT))\r\n                current.column--\r\n            if (direction.has(Direction.RIGHT))\r\n                current.column++\r\n\r\n            if (current.column == move.end.column && current.row == move.end.row) {\r\n                return false\r\n            }\r\n\r\n            if (board.getPieceAt(current) !== null)\r\n                return true\r\n        }\r\n    };\r\n    destinationBlocked = (move: MoveObject, board: BoardObject): boolean => {\r\n        const other = board.getPieceAt(move.end)\r\n        if (other == null || other == undefined)\r\n            return false\r\n        return other.color == this.color\r\n    };\r\n    checkMove(move: MoveObject, board: BoardObject): MoveState {\r\n        if (move.start == move.end)\r\n            return MoveState.NO_CHANGE\r\n        if (!this.validPath(move, board))\r\n            return MoveState.PATH_INVALID\r\n        if (!(board.getPieceAt(move.start) instanceof Knight) && this.pathBlocked(move, board))\r\n            return MoveState.PATH_BLOCKED\r\n        if (this.destinationBlocked(move, board))\r\n            return MoveState.DEST_BLOCKED\r\n\r\n        return MoveState.OK\r\n    };\r\n    abstract toString(): string;\r\n}\r\n\r\nexport class King extends Piece {\r\n    color: PieceColor\r\n    constructor(pieceColor: PieceColor) {\r\n        super()\r\n        this.color = pieceColor\r\n    }\r\n    override validPath = (move: MoveObject, board: BoardObject): boolean => {\r\n        const absoluteRow = Math.abs(move.start.row - move.end.row)\r\n        const absoluteColumn = Math.abs(move.start.column - move.end.column)\r\n        return absoluteRow <= 1 && absoluteColumn <= 1\r\n    }\r\n    toString = (): string => pieceToChar(this)\r\n}\r\n\r\nexport class Rook extends Piece {\r\n    color: PieceColor\r\n    constructor(pieceColor: PieceColor) {\r\n        super()\r\n        this.color = pieceColor\r\n    }\r\n    override validPath = (move: MoveObject, board: BoardObject): boolean => {\r\n        return move.start.column == move.end.column || move.start.row == move.end.row\r\n    }\r\n    toString = (): string => pieceToChar(this)\r\n}\r\n\r\nexport class Bishop extends Piece {\r\n    color: PieceColor\r\n    constructor(pieceColor: PieceColor) {\r\n        super()\r\n        this.color = pieceColor\r\n    }\r\n    override validPath = (move: MoveObject, board: BoardObject): boolean => {\r\n        return Math.abs(move.start.column - move.end.column) == Math.abs(move.start.row - move.end.row)\r\n    }\r\n    toString = (): string => pieceToChar(this)\r\n}\r\n\r\nexport class Queen extends Piece {\r\n    color: PieceColor\r\n    constructor(pieceColor: PieceColor) {\r\n        super()\r\n        this.color = pieceColor\r\n    }\r\n    override validPath = (move: MoveObject, board: BoardObject): boolean => {\r\n        return move.start.row == move.end.row\r\n            || move.start.column == move.end.column\r\n            || Math.abs(move.start.row - move.end.row) == Math.abs(move.start.column - move.end.column)\r\n    }\r\n    toString = (): string => pieceToChar(this)\r\n}\r\n\r\nexport class Knight extends Piece {\r\n    color: PieceColor\r\n    constructor(pieceColor: PieceColor) {\r\n        super()\r\n        this.color = pieceColor\r\n    }\r\n    override validPath = (move: MoveObject, board: BoardObject): boolean => {\r\n        return Math.abs(move.end.column - move.start.column) == 2 && Math.abs(move.end.row - move.start.row) == 1\r\n            || Math.abs(move.end.column - move.start.column) == 1 && Math.abs(move.end.row - move.start.row) == 2\r\n    }\r\n    toString = (): string => pieceToChar(this)\r\n}\r\n\r\nexport class Pawn extends Piece {\r\n\r\n    hasMoved = false\r\n    color: PieceColor\r\n\r\n    constructor(pieceColor: PieceColor) {\r\n        super()\r\n        this.color = pieceColor\r\n    }\r\n    override validPath = (move: MoveObject, board: BoardObject): boolean => {\r\n        const steps = this.hasMoved ? 1 : 2\r\n        const direction = selectByPieceColor(this.color, -1, 1)\r\n\r\n        return (\r\n            // Vertical movement\r\n            move.start.column == move.end.column\r\n            && (direction == -1 ?\r\n                (board.getPieceAt(move.end) == null && move.start.row > move.end.row && move.start.row - move.end.row <= steps)\r\n                :\r\n                (board.getPieceAt(move.end) == null && move.end.row > move.start.row && move.end.row - move.start.row <= steps)\r\n            )\r\n        )\r\n            ||\r\n            (\r\n                // Horizontal movement\r\n                Math.abs(move.start.column - move.end.column) == 1\r\n                && move.end.row - move.start.row == direction\r\n                && board.getPieceAt(move.end) != null\r\n            )\r\n    }\r\n    toString = (): string => pieceToChar(this)\r\n}\r\n\r\nconst charPieceMap = {\r\n    'K': King,\r\n    'R': Rook,\r\n    'B': Bishop,\r\n    'Q': Queen,\r\n    'N': Knight,\r\n    'P': Pawn,\r\n}\r\n\r\nconst charPieces = ['K', 'R', 'B', 'Q', 'N', 'P']\r\n\r\nexport const charToPiece = (char: string) => {\r\n    for (const entry of Object.entries(charPieceMap)) {\r\n        const pieceChar = entry[0]\r\n        const pieceClass = entry[1]\r\n        if (pieceChar === char.toUpperCase()) {\r\n            // console.log(\"FOUND:\", pieceChar, pieceClass.name)\r\n            const color = char === char.toUpperCase() ? PieceColor.WHITE : PieceColor.BLACK\r\n            const newPiece = new pieceClass(color)\r\n            console.log(newPiece)\r\n            return newPiece\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\nexport const pieceToChar = (piece: Piece) => {\r\n    let pieceChar\r\n    if (piece instanceof Knight) {\r\n        pieceChar = 'N'\r\n    }\r\n    else {\r\n        pieceChar = piece.constructor.name[0]\r\n    }\r\n    return selectByPieceColor(piece.color, pieceChar.toUpperCase(), pieceChar.toLowerCase())\r\n}"]},"metadata":{},"sourceType":"module"}