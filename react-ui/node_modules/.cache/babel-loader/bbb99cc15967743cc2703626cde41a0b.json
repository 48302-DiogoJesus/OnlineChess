{"ast":null,"code":"import { charToPiece, selectByPieceColor, PieceColor, King, Pawn, Knight, Queen, Rook, Bishop, getOpponent, pieceToChar, MoveState } from './piece';\nimport { Position, stringToMove, Move } from './position';\nimport ERRORS from './errors';\nexport const BOARD_WIDTH = 8;\nexport const BOARD_HEIGHT = 8;\n/**\r\n * Board Object\r\n * Representation of a board and all it's permitted operations\r\n */\n\nexport class BoardObject {\n  /**\r\n   * BoardObject Class contructor\r\n   * @param {initBoard} If true it will initialize this.board with pieces at default positions (true by default)\r\n   * @returns A new instance of BoardObject\r\n   */\n  constructor() {\n    let initBoard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.board = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(null));\n    this.winner = null;\n    this.turn = PieceColor.WHITE;\n\n    this.setPieceAt = (position, piece) => this.board[position.row][position.column] = piece;\n\n    this.getPieceAt = position => this.board[position.row][position.column];\n\n    this.findKingPosition = () => {\n      for (let row = 0; row < BOARD_HEIGHT; row++) {\n        for (let col = 0; col < BOARD_WIDTH; col++) {\n          const currentPosition = Position(col, row);\n          const currentPiece = this.getPieceAt(currentPosition);\n          if (currentPiece instanceof King && this.turn == currentPiece.color) return currentPosition;\n        }\n      }\n\n      return null;\n    };\n\n    this.generateAllPossibleTargets = piecePosition => {\n      const possibleEndPositions = new Set();\n      const piece = this.getPieceAt(piecePosition);\n      if (piece === null) return possibleEndPositions;\n\n      for (let row = 0; row < BOARD_HEIGHT; row++) {\n        for (let col = 0; col < BOARD_WIDTH; col++) {\n          const currentPosition = Position(col, row);\n          const pieceAtEndPos = this.getPieceAt(Position(col, row)); // If piece is from the same player trying to make the move don't try it\n\n          if (pieceAtEndPos != null && pieceAtEndPos.color == piece.color) continue;\n          const moveState = piece.checkMove(Move(pieceToChar(piece), piecePosition, currentPosition), this);\n\n          if (moveState == MoveState.OK) {\n            possibleEndPositions.add(currentPosition);\n          }\n        }\n      }\n\n      return possibleEndPositions;\n    };\n\n    this.isInCheckMate = () => this.isInCheck() && this.generateSafeKingTargets().size === 0;\n\n    this.isInCheck = () => {\n      const kingPosition = this.findKingPosition();\n      if (kingPosition === null) return false;\n\n      for (let row = 0; row < BOARD_HEIGHT; row++) {\n        for (let col = 0; col < BOARD_WIDTH; col++) {\n          const piecePosition = Position(col, row);\n          const piece = this.getPieceAt(piecePosition);\n\n          if (piece != null && piece.color == getOpponent(this.turn)) {\n            const possibleMovesForPiece = this.generateAllPossibleTargets(piecePosition);\n            possibleMovesForPiece.forEach(move => {\n              if (move.column === kingPosition.column && move.row === kingPosition.row) return true;\n            });\n          }\n        }\n      }\n\n      return false;\n    };\n\n    this.makeMove = moveAsString => {\n      const move = stringToMove(moveAsString);\n      const maybePromotionPiece = charToPiece(selectByPieceColor(this.turn, move.pieceChar.toUpperCase(), move.pieceChar.toLowerCase()));\n      const piece = this.getPieceAt(move.start);\n      const capturePiece = this.getPieceAt(move.end);\n\n      if (this.winner !== null) {\n        throw ERRORS.ALREADY_OVER;\n      }\n\n      if (piece === null) throw ERRORS.NO_PIECE_AT_START_POSITION;\n\n      if (!(piece instanceof King) && this.isInCheck()) {\n        throw ERRORS.KING_IN_CHECK;\n      }\n\n      if ( // When true means Promotion\n      maybePromotionPiece.toString().toUpperCase() != piece.toString().toUpperCase() && // Check if it is a Pawn and if it's not a game winning move\n      piece instanceof Pawn && !(capturePiece instanceof King) && ( // Check if it's valid promotion piece\n      maybePromotionPiece instanceof Knight || maybePromotionPiece instanceof Queen || maybePromotionPiece instanceof Bishop || maybePromotionPiece instanceof Rook)) {\n        // Transform pawn\n        this.setPieceAt(move.end, maybePromotionPiece);\n        this.setPieceAt(move.start, null);\n      } else {\n        this.setPieceAt(move.end, piece);\n        this.setPieceAt(move.start, null);\n      }\n\n      if (piece instanceof Pawn) piece.hasMoved = true;\n      if (capturePiece instanceof King) this.winner = this.turn;\n      this.turn = getOpponent(this.turn); // If this move makes the other player's King be in check and with nowhere to go tell board he won\n\n      if (this.isInCheck() && this.generateSafeKingTargets().size === 0) this.winner = getOpponent(this.turn);\n    };\n\n    this.setRow = (rowStr, rowNum) => {\n      for (let colNum = 0; colNum < BOARD_WIDTH; colNum++) {\n        const pieceChar = rowStr[colNum];\n\n        if (pieceChar !== undefined) {\n          this.setPieceAt(Position(colNum, rowNum), charToPiece(rowStr[colNum]));\n        }\n      }\n    };\n\n    if (initBoard) {\n      this.initBoard();\n    }\n  }\n  /**\r\n   * Initialize Board\r\n   * Set the default rows with the default chess pieces in the current board\r\n   */\n\n\n  initBoard() {\n    // Set White pieces\n    this.setRow(\"rnbqkbnr\", 0);\n    this.setRow(\"pppppppp\", 1); // Set Black pieces\n\n    this.setRow(\"PPPPPPPP\", BOARD_HEIGHT - 2);\n    this.setRow(\"RNBQKBNR\", BOARD_HEIGHT - 1);\n  }\n  /**\r\n   * Set Piece At\r\n   * Set a piece at a certain board position\r\n   * @param {position} Position in the board to put the new piece. Has a row and a column\r\n   * @param {piece} Piece to place at [position] in the board\r\n   * @returns A Piece if there is a piece at [position], null if not\r\n   */\n\n\n  generateSafeKingTargets() {\n    const kingPosition = this.findKingPosition();\n    if (kingPosition == null) return new Set(); // Initial King Targets (Mutable set to remove in the end)\n    // Could also return a new Set with the exclusion of both Sets\n\n    const possibleKingTargets = this.generateAllPossibleTargets(kingPosition); // Set that will store the suicide positions for the King\n\n    const collisions = new Set();\n    this.setPieceAt(kingPosition, null);\n    possibleKingTargets.forEach(target => {\n      // Remove King from the board to corretly make the predictions\n      // For all the board pieces\n      for (let row = 0; row < BOARD_HEIGHT; row++) {\n        for (let col = 0; col < BOARD_WIDTH; col++) {\n          const enemyPosition = Position(col, row);\n          const enemyPiece = this.getPieceAt(enemyPosition);\n          const targetPiece = this.getPieceAt(target);\n          this.setPieceAt(target, null);\n          /*\r\n           If Enemy Piece Generate it's possible moves and those that match the\r\n           king targets are added to the \"collisions\" Set\r\n           */\n\n          if (enemyPiece != null && enemyPiece.color != this.turn) {\n            const possibleEnemyTargets = this.generateAllPossibleTargets(enemyPosition);\n            /*\r\n             If piece is a pawn it can only eat in diagonal so moving forward is not a threat to King\r\n             */\n\n            if (enemyPiece instanceof Pawn) {\n              const direction = selectByPieceColor(this.turn, -1, 1); // Add diagonals as Pawn targets\n\n              if (enemyPosition.column < BOARD_WIDTH - 1) possibleEnemyTargets.add(Position(enemyPosition.column + 1, enemyPosition.row - direction));\n              if (enemyPosition.column > 0) possibleEnemyTargets.add(Position(enemyPosition.column - 1, enemyPosition.row - direction)); // Remove targets in which pawn moves vertically\n\n              possibleEnemyTargets.forEach(enemyTarget => {\n                if (enemyTarget.column == enemyPosition.column) possibleEnemyTargets.delete(enemyTarget);\n              });\n            } // Remove suicide targets\n\n\n            possibleEnemyTargets.forEach(enemyTarget => {\n              possibleKingTargets.forEach(target => {\n                if (enemyTarget.column === target.column && enemyTarget.row === target.row) collisions.add(enemyTarget);\n              });\n            });\n          } // Put target piece back again\n\n\n          this.setPieceAt(target, targetPiece);\n        }\n      }\n    }); // Put King back to the board after predicting enemy targets\n\n    this.setPieceAt(kingPosition, new King(this.turn));\n    /*\r\n     Remove from the King targets the suicide positions\r\n     */\n\n    possibleKingTargets.forEach(kingPos => {\n      collisions.forEach(collision => {\n        if (collision.column === kingPos.column && collision.row === kingPos.row) possibleKingTargets.delete(kingPos);\n      });\n    });\n    return possibleKingTargets;\n  }\n\n  /**\r\n   * Board to String\r\n   * Convert the current board to a string\r\n   * @returns a string representation of this.board\r\n   */\n  toString() {\n    var boardAsString = \"\";\n    this.board.map((row, rowIdx) => row.map((col, colIdx) => {\n      const piece = this.getPieceAt(Position(colIdx, rowIdx));\n\n      if (piece == null) {\n        boardAsString += \" \";\n      } else {\n        boardAsString += selectByPieceColor(piece.color, piece.toString().toUpperCase(), piece.toString());\n      }\n    }));\n    return boardAsString;\n  }\n  /**\r\n   * Set Board Row\r\n   * Sets the pieces for a specific row on the board\r\n   * @param {rowStr} Representation of the row as a string of [BOARD_WIDTH] characters\r\n   * @param {rowNum} Row number to identify the row. From 0 to [BOARD_HEIGHT]\r\n   */\n\n\n}\n/**\r\n * String to Board\r\n * Convert a string to a board\r\n * If a char corresponds to a valid piece set that piece in the {newBoard}, if not set an empty Tile in the {newBoard}\r\n * @param {boardAsString} Example of a default board: \"rnbqkbnrpppppppp                                PPPPPPPPRNBQKBNR\"\r\n * @returns A new BoardObject if {boardAsString} is convertible to a board, null if not\r\n */\n\nexport function stringToBoard(boardAsString) {\n  if (boardAsString.length != BOARD_WIDTH * BOARD_HEIGHT) throw ERRORS.BAD_BOARD_STRING;\n  const newBoard = new BoardObject();\n\n  for (let row = 0, currChar = 0; row < BOARD_HEIGHT; row++) {\n    for (let col = 0; col < BOARD_WIDTH; col++, currChar++) {\n      const pieceChar = boardAsString[currChar];\n      const piece = charToPiece(pieceChar); // [piece] will be null if char does not correspond to a piece. Case of the \" \" representing an empty Tile\n\n      newBoard.setPieceAt(Position(col, row), piece);\n    }\n  }\n\n  return newBoard;\n}","map":{"version":3,"sources":["C:/Users/jesus/Desktop/PG/Personal/1-Web/TS/OnlineChess/onlinechess/src/domain/board.ts"],"names":["charToPiece","selectByPieceColor","PieceColor","King","Pawn","Knight","Queen","Rook","Bishop","getOpponent","pieceToChar","MoveState","Position","stringToMove","Move","ERRORS","BOARD_WIDTH","BOARD_HEIGHT","BoardObject","constructor","initBoard","board","Array","fill","map","winner","turn","WHITE","setPieceAt","position","piece","row","column","getPieceAt","findKingPosition","col","currentPosition","currentPiece","color","generateAllPossibleTargets","piecePosition","possibleEndPositions","Set","pieceAtEndPos","moveState","checkMove","OK","add","isInCheckMate","isInCheck","generateSafeKingTargets","size","kingPosition","possibleMovesForPiece","forEach","move","makeMove","moveAsString","maybePromotionPiece","pieceChar","toUpperCase","toLowerCase","start","capturePiece","end","ALREADY_OVER","NO_PIECE_AT_START_POSITION","KING_IN_CHECK","toString","hasMoved","setRow","rowStr","rowNum","colNum","undefined","possibleKingTargets","collisions","target","enemyPosition","enemyPiece","targetPiece","possibleEnemyTargets","direction","enemyTarget","delete","kingPos","collision","boardAsString","rowIdx","colIdx","stringToBoard","length","BAD_BOARD_STRING","newBoard","currChar"],"mappings":"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","sourcesContent":["import { \r\n  Piece,\r\n  charToPiece,\r\n  selectByPieceColor,\r\n  PieceColor,\r\n  King,\r\n  Pawn,\r\n  Knight,\r\n  Queen,\r\n  Rook,\r\n  Bishop, \r\n  getOpponent,\r\n  pieceToChar,\r\n  MoveState\r\n} from './piece'\r\nimport { PositionObject, Position, stringToMove, Move } from './position'\r\nimport ERRORS from './errors'\r\n\r\nexport const BOARD_WIDTH = 8;\r\nexport const BOARD_HEIGHT = 8;\r\n\r\n/**\r\n * Board Object\r\n * Representation of a board and all it's permitted operations\r\n */\r\nexport class BoardObject {\r\n\r\n  board: Array<Array<Piece | null>> = Array(BOARD_HEIGHT).fill(null).map(()=>Array(BOARD_WIDTH).fill(null));\r\n  winner: PieceColor | null = null\r\n  turn: PieceColor = PieceColor.WHITE\r\n\r\n  /**\r\n   * BoardObject Class contructor\r\n   * @param {initBoard} If true it will initialize this.board with pieces at default positions (true by default)\r\n   * @returns A new instance of BoardObject\r\n   */ \r\n  constructor(initBoard: boolean = true) {\r\n    if (initBoard) {\r\n      this.initBoard()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize Board\r\n   * Set the default rows with the default chess pieces in the current board\r\n   */\r\n   initBoard() {\r\n    // Set White pieces\r\n    this.setRow(\"rnbqkbnr\", 0)\r\n    this.setRow(\"pppppppp\", 1)\r\n    // Set Black pieces\r\n    this.setRow(\"PPPPPPPP\", BOARD_HEIGHT - 2)\r\n    this.setRow(\"RNBQKBNR\", BOARD_HEIGHT - 1)\r\n  }\r\n\r\n  /**\r\n   * Set Piece At\r\n   * Set a piece at a certain board position\r\n   * @param {position} Position in the board to put the new piece. Has a row and a column\r\n   * @param {piece} Piece to place at [position] in the board\r\n   * @returns A Piece if there is a piece at [position], null if not\r\n   */\r\n  setPieceAt = (position: PositionObject, piece: Piece | null) => this.board[position.row][position.column] = piece\r\n\r\n  /**\r\n   * Get Piece At\r\n   * Get the piece at a certain board position\r\n   * @param {position} Position in the board. Has a row and a column\r\n   * @returns A Piece if there is a piece at [position], null if not\r\n   */\r\n  getPieceAt = (position: PositionObject) => this.board[position.row][position.column]\r\n\r\n  findKingPosition = (): PositionObject | null => {\r\n    for (let row = 0; row < BOARD_HEIGHT; row++) {\r\n      for (let col = 0; col < BOARD_WIDTH; col++) {\r\n          const currentPosition = Position(col, row)\r\n          const currentPiece = this.getPieceAt(currentPosition)\r\n          if (currentPiece instanceof King && this.turn == currentPiece.color)\r\n            return currentPosition\r\n      }\r\n    }\r\n    return null\r\n  }\r\n\r\n  generateAllPossibleTargets = (piecePosition: PositionObject): Set<PositionObject> => {\r\n    const possibleEndPositions = new Set<PositionObject>()\r\n    const piece = this.getPieceAt(piecePosition)\r\n    if (piece === null)\r\n      return possibleEndPositions\r\n\r\n      for (let row = 0; row < BOARD_HEIGHT; row++) {\r\n        for (let col = 0; col < BOARD_WIDTH; col++) {\r\n            const currentPosition = Position(col, row)\r\n            const pieceAtEndPos = this.getPieceAt(Position(col, row))\r\n\r\n            // If piece is from the same player trying to make the move don't try it\r\n            if (pieceAtEndPos != null && pieceAtEndPos.color == piece.color)\r\n              continue\r\n            \r\n            const moveState = piece.checkMove(Move(pieceToChar(piece), piecePosition, currentPosition), this)\r\n\r\n            if (moveState == MoveState.OK) {\r\n              possibleEndPositions.add(currentPosition)\r\n            }\r\n        }\r\n    }\r\n    return possibleEndPositions\r\n  }\r\n\r\n  generateSafeKingTargets(): Set<PositionObject> {\r\n    const kingPosition = this.findKingPosition()\r\n\r\n    if (kingPosition == null)\r\n      return new Set<PositionObject>()\r\n\r\n    // Initial King Targets (Mutable set to remove in the end)\r\n    // Could also return a new Set with the exclusion of both Sets\r\n    const possibleKingTargets = this.generateAllPossibleTargets(kingPosition)\r\n\r\n    // Set that will store the suicide positions for the King\r\n    const collisions = new Set<PositionObject>()\r\n\r\n    this.setPieceAt(kingPosition, null)\r\n\r\n    possibleKingTargets.forEach((target) => {\r\n    // Remove King from the board to corretly make the predictions\r\n        // For all the board pieces\r\n        for (let row = 0; row < BOARD_HEIGHT; row++) {\r\n          for (let col = 0; col < BOARD_WIDTH; col++) {\r\n                const enemyPosition = Position(col, row)\r\n                const enemyPiece = this.getPieceAt(enemyPosition)\r\n\r\n                const targetPiece = this.getPieceAt(target)\r\n                this.setPieceAt(target, null)\r\n                /*\r\n                 If Enemy Piece Generate it's possible moves and those that match the\r\n                 king targets are added to the \"collisions\" Set\r\n                 */\r\n                if (enemyPiece != null && enemyPiece.color != this.turn) {\r\n                    const possibleEnemyTargets = this.generateAllPossibleTargets(enemyPosition)\r\n                    /*\r\n                     If piece is a pawn it can only eat in diagonal so moving forward is not a threat to King\r\n                     */\r\n                    if (enemyPiece instanceof Pawn) {\r\n                        const direction = selectByPieceColor(this.turn, -1, 1)\r\n                        // Add diagonals as Pawn targets\r\n                        if (enemyPosition.column < BOARD_WIDTH - 1)\r\n                            possibleEnemyTargets.add(Position(enemyPosition.column + 1, enemyPosition.row - direction))\r\n                        if (enemyPosition.column > 0)\r\n                            possibleEnemyTargets.add(Position(enemyPosition.column - 1, enemyPosition.row - direction))\r\n\r\n                        // Remove targets in which pawn moves vertically\r\n                        possibleEnemyTargets.forEach((enemyTarget: PositionObject) => {\r\n                          if (enemyTarget.column == enemyPosition.column)\r\n                            possibleEnemyTargets.delete(enemyTarget)\r\n                        })\r\n                    }\r\n                    // Remove suicide targets\r\n                    possibleEnemyTargets.forEach((enemyTarget) => {\r\n                      possibleKingTargets.forEach(target => {\r\n                        if (enemyTarget.column === target.column && enemyTarget.row === target.row)\r\n                        collisions.add(enemyTarget)\r\n                      })\r\n                      })\r\n                }\r\n                // Put target piece back again\r\n                this.setPieceAt(target, targetPiece)\r\n            }\r\n        }\r\n    })\r\n        \r\n    // Put King back to the board after predicting enemy targets\r\n    this.setPieceAt(kingPosition, new King(this.turn))\r\n    /*\r\n     Remove from the King targets the suicide positions\r\n     */\r\n    possibleKingTargets.forEach((kingPos: PositionObject) => {\r\n      collisions.forEach(collision => {\r\n        if (collision.column === kingPos.column && collision.row === kingPos.row)\r\n          possibleKingTargets.delete(kingPos)\r\n      })\r\n    })\r\n    return possibleKingTargets\r\n  }\r\n\r\n  isInCheckMate = () => this.isInCheck() && (this.generateSafeKingTargets().size === 0)\r\n\r\n  isInCheck = (): boolean => {\r\n    const kingPosition = this.findKingPosition()\r\n    if (kingPosition === null) return false\r\n\r\n    for (let row = 0; row < BOARD_HEIGHT; row++) {\r\n      for (let col = 0; col < BOARD_WIDTH; col++) {\r\n        const piecePosition = Position(col, row)\r\n        const piece = this.getPieceAt(piecePosition)\r\n        if (piece != null && piece.color == getOpponent(this.turn)) {\r\n          const possibleMovesForPiece = this.generateAllPossibleTargets(piecePosition)\r\n          possibleMovesForPiece.forEach(move => {\r\n            if (move.column === kingPosition.column && move.row === kingPosition.row)  \r\n              return true\r\n          })\r\n        }\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  makeMove = (moveAsString: string) => {\r\n    const move = stringToMove(moveAsString)\r\n    const maybePromotionPiece = charToPiece(selectByPieceColor(this.turn, move.pieceChar.toUpperCase(), move.pieceChar.toLowerCase()))!!\r\n    const piece = this.getPieceAt(move.start)\r\n    const capturePiece = this.getPieceAt(move.end)\r\n\r\n    if (this.winner !== null) {\r\n      throw ERRORS.ALREADY_OVER\r\n    }\r\n\r\n    if (piece === null) throw ERRORS.NO_PIECE_AT_START_POSITION\r\n\r\n    if (!(piece instanceof King) && this.isInCheck()) {\r\n      throw ERRORS.KING_IN_CHECK\r\n    }\r\n\r\n    if (\r\n      // When true means Promotion\r\n      maybePromotionPiece.toString().toUpperCase() != piece.toString().toUpperCase() &&\r\n      // Check if it is a Pawn and if it's not a game winning move\r\n      (piece instanceof Pawn) && !(capturePiece instanceof King) &&\r\n      // Check if it's valid promotion piece\r\n      (maybePromotionPiece instanceof Knight || maybePromotionPiece instanceof Queen || maybePromotionPiece instanceof Bishop || maybePromotionPiece instanceof Rook)\r\n    ) {\r\n        // Transform pawn\r\n        this.setPieceAt(move.end, maybePromotionPiece)\r\n        this.setPieceAt(move.start, null)\r\n    } else {\r\n        this.setPieceAt(move.end, piece)\r\n        this.setPieceAt(move.start, null)\r\n    }\r\n\r\n    if (piece instanceof Pawn)\r\n        piece.hasMoved = true\r\n\r\n    if (capturePiece instanceof King)\r\n        this.winner = this.turn\r\n\r\n    this.turn = getOpponent(this.turn)\r\n\r\n    // If this move makes the other player's King be in check and with nowhere to go tell board he won\r\n    if (this.isInCheck() && this.generateSafeKingTargets().size === 0)\r\n        this.winner = getOpponent(this.turn)\r\n  }\r\n\r\n  /**\r\n   * Board to String\r\n   * Convert the current board to a string\r\n   * @returns a string representation of this.board\r\n   */\r\n  toString() {\r\n    var boardAsString: string = \"\"\r\n    this.board.map((row, rowIdx) => row.map((col, colIdx) => { \r\n      const piece = this.getPieceAt(Position(colIdx, rowIdx))\r\n      if (piece == null) {\r\n        boardAsString += \" \"\r\n      } else { \r\n        boardAsString += selectByPieceColor(piece.color, piece.toString().toUpperCase(), piece.toString())\r\n      }\r\n    }))\r\n    return boardAsString\r\n  }\r\n\r\n  /**\r\n   * Set Board Row\r\n   * Sets the pieces for a specific row on the board\r\n   * @param {rowStr} Representation of the row as a string of [BOARD_WIDTH] characters\r\n   * @param {rowNum} Row number to identify the row. From 0 to [BOARD_HEIGHT]\r\n   */\r\n  setRow = (rowStr: string, rowNum: number) => {\r\n    for (let colNum = 0; colNum < BOARD_WIDTH; colNum++) {\r\n      const pieceChar = rowStr[colNum]\r\n      if (pieceChar !== undefined) {\r\n        this.setPieceAt(Position(colNum, rowNum), charToPiece(rowStr[colNum])!!)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * String to Board\r\n * Convert a string to a board\r\n * If a char corresponds to a valid piece set that piece in the {newBoard}, if not set an empty Tile in the {newBoard}\r\n * @param {boardAsString} Example of a default board: \"rnbqkbnrpppppppp                                PPPPPPPPRNBQKBNR\"\r\n * @returns A new BoardObject if {boardAsString} is convertible to a board, null if not\r\n */\r\nexport function stringToBoard(boardAsString: string): BoardObject | null {\r\n  if (boardAsString.length != BOARD_WIDTH * BOARD_HEIGHT)\r\n    throw ERRORS.BAD_BOARD_STRING\r\n  const newBoard = new BoardObject()\r\n  for (let row = 0, currChar = 0; row < BOARD_HEIGHT; row++) {\r\n    for (let col = 0; col < BOARD_WIDTH; col++, currChar++) {\r\n      const pieceChar = boardAsString[currChar]\r\n        const piece: Piece | null = charToPiece(pieceChar)\r\n        // [piece] will be null if char does not correspond to a piece. Case of the \" \" representing an empty Tile\r\n        newBoard.setPieceAt(Position(col, row), piece)\r\n    }\r\n  }\r\n  return newBoard\r\n}"]},"metadata":{},"sourceType":"module"}