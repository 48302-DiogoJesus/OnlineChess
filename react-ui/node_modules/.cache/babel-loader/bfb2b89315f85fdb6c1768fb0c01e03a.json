{"ast":null,"code":"import { charToPiece, selectByPieceColor, PieceColor, King, Pawn, Knight, Queen, Rook, Bishop, getOpponent, pieceToChar, MoveState } from './piece';\nimport { Position, stringToMove, Move, moveToString } from './position';\nimport ERROR from './errors';\nexport const BOARD_WIDTH = 8;\nexport const BOARD_HEIGHT = 8;\n/**\r\n * Board Object\r\n * Representation of a board and all it's permitted operations\r\n */\n\nexport class BoardObject {\n  /**\r\n   * BoardObject Class contructor\r\n   * @param {initBoard} If true it will initialize this.board with pieces at default positions (true by default)\r\n   * @returns A new instance of BoardObject\r\n   */\n  constructor() {\n    let initTurn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let initBoard = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.board = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(null));\n    this.winner = null;\n    this.turn = PieceColor.WHITE;\n    this.moves = [];\n\n    this.setPieceAt = (position, piece) => this.board[position.row][position.column] = piece;\n\n    this.getPieceAt = position => this.board[position.row][position.column];\n\n    this.findKingPosition = () => {\n      for (let row = 0; row < BOARD_HEIGHT; row++) {\n        for (let col = 0; col < BOARD_WIDTH; col++) {\n          const currentPosition = Position(col, row);\n          const currentPiece = this.getPieceAt(currentPosition);\n          if (currentPiece instanceof King && this.turn == currentPiece.color) return currentPosition;\n        }\n      }\n\n      return null;\n    };\n\n    this.generateAllPossibleTargets = piecePosition => {\n      const possibleEndPositions = new Set();\n      const piece = this.getPieceAt(piecePosition);\n      if (piece === null) return possibleEndPositions;\n\n      for (let row = 0; row < BOARD_HEIGHT; row++) {\n        for (let col = 0; col < BOARD_WIDTH; col++) {\n          const currentPosition = Position(col, row);\n          const pieceAtEndPos = this.getPieceAt(Position(col, row)); // If piece is from the same player trying to make the move don't try it\n\n          if (pieceAtEndPos != null && pieceAtEndPos.color == piece.color) continue;\n          const moveState = piece.checkMove(Move(pieceToChar(piece), piecePosition, currentPosition), this);\n\n          if (moveState == MoveState.OK) {\n            possibleEndPositions.add(currentPosition);\n          }\n        }\n      }\n\n      return possibleEndPositions;\n    };\n\n    this.isInCheckMate = () => this.isInCheck() && this.generateSafeKingTargets().size === 0;\n\n    this.isInCheck = () => {\n      const kingPosition = this.findKingPosition();\n      if (kingPosition === null) return false;\n\n      for (let row = 0; row < BOARD_HEIGHT; row++) {\n        for (let col = 0; col < BOARD_WIDTH; col++) {\n          const piecePosition = Position(col, row);\n          const piece = this.getPieceAt(piecePosition);\n\n          if (piece != null && piece.color == getOpponent(this.turn)) {\n            const possibleMovesForPiece = this.generateAllPossibleTargets(piecePosition);\n            possibleMovesForPiece.forEach(move => {\n              if (move.column === kingPosition.column && move.row === kingPosition.row) return true;\n            });\n          }\n        }\n      }\n\n      return false;\n    };\n\n    this.isPromotionMove = moveAsString => {\n      const move = stringToMove(moveAsString);\n      const piece = this.getPieceAt(move.start);\n\n      if (!(piece instanceof Pawn)) {\n        return false;\n      }\n\n      if (this.turn == PieceColor.WHITE && move.end.row == 0) {\n        return true;\n      }\n\n      if (this.turn == PieceColor.BLACK && move.end.row == 7) {\n        return true;\n      }\n\n      return false;\n    };\n\n    this.makeMove = moveAsString => {\n      const move = stringToMove(moveAsString);\n      const maybePromotionPiece = charToPiece(selectByPieceColor(this.turn, move.pieceChar.toUpperCase(), move.pieceChar.toLowerCase()));\n      const piece = this.getPieceAt(move.start);\n      const capturePiece = this.getPieceAt(move.end);\n\n      if (this.winner != null) {\n        throw ERROR.ALREADY_OVER;\n      }\n\n      if (piece === null) throw ERROR.NO_PIECE_AT_START_POSITION;\n      /*\r\n      if (!(piece instanceof King) && this.isInCheck()) {\r\n        throw ERROR.KING_IN_CHECK\r\n      }\r\n      */\n\n      const isPromotion = maybePromotionPiece.toString().toUpperCase() != piece.toString().toUpperCase();\n\n      if ( // When true means Promotion\n      isPromotion && // Check if it is a Pawn and if it's not a game winning move\n      piece instanceof Pawn && !(capturePiece instanceof King) && ( // Check if it's valid promotion piece\n      maybePromotionPiece instanceof Knight || maybePromotionPiece instanceof Queen || maybePromotionPiece instanceof Bishop || maybePromotionPiece instanceof Rook)) {\n        // Transform pawn\n        this.setPieceAt(move.end, maybePromotionPiece);\n        this.setPieceAt(move.start, null);\n      } else {\n        this.setPieceAt(move.end, piece);\n        this.setPieceAt(move.start, null);\n      }\n\n      if (piece instanceof Pawn) piece.hasMoved = true; // If this move makes the other player's King be in check and with nowhere to go tell board he won\n\n      if (this.isInCheck() && this.generateSafeKingTargets().size === 0) this.winner = getOpponent(this.turn);\n      this.turn = getOpponent(this.turn);\n      this.updateWinner();\n      this.moves.push(move);\n    };\n\n    this.setRow = (rowStr, rowNum) => {\n      for (let colNum = 0; colNum < BOARD_WIDTH; colNum++) {\n        const pieceChar = rowStr[colNum];\n\n        if (pieceChar !== undefined) {\n          console.log(\"setting piece:\", Position(colNum, rowNum), charToPiece(pieceChar));\n          this.setPieceAt(Position(colNum, rowNum), charToPiece(pieceChar));\n        }\n      }\n\n      console.log(this.findKingPosition());\n      console.log(this.toString());\n    };\n\n    if (initBoard) {\n      this.initBoard();\n    }\n\n    if (initTurn != null) {\n      this.turn = initTurn;\n    }\n  }\n\n  stringMoves() {\n    return this.moves.map(move => moveToString(move));\n  }\n  /**\r\n   * Initialize Board\r\n   * Set the default rows with the default chess pieces in the current board\r\n   */\n\n\n  initBoard() {\n    // Set White pieces\n    this.setRow(\"rnbqkbnr\", 0);\n    this.setRow(\"pppppppp\", 1); // Set Black pieces\n\n    this.setRow(\"PPPPPPPP\", BOARD_HEIGHT - 2);\n    this.setRow(\"RNBQKBNR\", BOARD_HEIGHT - 1);\n  }\n\n  static fromMoves(moves) {\n    const baseBoard = new BoardObject();\n\n    for (const move of moves) {\n      baseBoard.makeMove(move);\n    }\n\n    return baseBoard;\n  }\n  /**\r\n   * Set Piece At\r\n   * Set a piece at a certain board position\r\n   * @param {position} Position in the board to put the new piece. Has a row and a column\r\n   * @param {piece} Piece to place at [position] in the board\r\n   * @returns A Piece if there is a piece at [position], null if not\r\n   */\n\n\n  generateSafeKingTargets() {\n    const kingPosition = this.findKingPosition();\n    if (kingPosition == null) return new Set(); // Initial King Targets (Mutable set to remove in the end)\n    // Could also return a new Set with the exclusion of both Sets\n\n    const possibleKingTargets = this.generateAllPossibleTargets(kingPosition); // Set that will store the suicide positions for the King\n\n    const collisions = new Set();\n    this.setPieceAt(kingPosition, null);\n    possibleKingTargets.forEach(target => {\n      // Remove King from the board to corretly make the predictions\n      // For all the board pieces\n      for (let row = 0; row < BOARD_HEIGHT; row++) {\n        for (let col = 0; col < BOARD_WIDTH; col++) {\n          const enemyPosition = Position(col, row);\n          const enemyPiece = this.getPieceAt(enemyPosition);\n          const targetPiece = this.getPieceAt(target);\n          this.setPieceAt(target, null);\n          /*\r\n           If Enemy Piece Generate it's possible moves and those that match the\r\n           king targets are added to the \"collisions\" Set\r\n           */\n\n          if (enemyPiece != null && enemyPiece.color != this.turn) {\n            const possibleEnemyTargets = this.generateAllPossibleTargets(enemyPosition);\n            /*\r\n             If piece is a pawn it can only eat in diagonal so moving forward is not a threat to King\r\n             */\n\n            if (enemyPiece instanceof Pawn) {\n              const direction = selectByPieceColor(this.turn, -1, 1); // Add diagonals as Pawn targets\n\n              if (enemyPosition.column < BOARD_WIDTH - 1) possibleEnemyTargets.add(Position(enemyPosition.column + 1, enemyPosition.row - direction));\n              if (enemyPosition.column > 0) possibleEnemyTargets.add(Position(enemyPosition.column - 1, enemyPosition.row - direction)); // Remove targets in which pawn moves vertically\n\n              possibleEnemyTargets.forEach(enemyTarget => {\n                if (enemyTarget.column == enemyPosition.column) possibleEnemyTargets.delete(enemyTarget);\n              });\n            } // Remove suicide targets\n\n\n            possibleEnemyTargets.forEach(enemyTarget => {\n              possibleKingTargets.forEach(target => {\n                if (enemyTarget.column === target.column && enemyTarget.row === target.row) collisions.add(enemyTarget);\n              });\n            });\n          } // Put target piece back again\n\n\n          this.setPieceAt(target, targetPiece);\n        }\n      }\n    }); // Put King back to the board after predicting enemy targets\n\n    this.setPieceAt(kingPosition, new King(this.turn));\n    /*\r\n     Remove from the King targets the suicide positions\r\n     */\n\n    possibleKingTargets.forEach(kingPos => {\n      collisions.forEach(collision => {\n        if (collision.column === kingPos.column && collision.row === kingPos.row) possibleKingTargets.delete(kingPos);\n      });\n    });\n    return possibleKingTargets;\n  }\n\n  updateWinner() {\n    if (this.findKingPosition() == null) {\n      this.winner = getOpponent(this.turn);\n    }\n\n    const backupTurn = this.turn;\n    this.turn = getOpponent(this.turn);\n\n    if (this.findKingPosition() == null) {\n      this.winner = getOpponent(this.turn);\n    }\n\n    this.turn = backupTurn;\n  }\n  /**\r\n   * Board to String\r\n   * Convert the current board to a string\r\n   * @returns a string representation of this.board\r\n   */\n\n\n  toString() {\n    var boardAsString = \"\";\n    this.board.map((row, rowIdx) => row.map((col, colIdx) => {\n      const piece = this.getPieceAt(Position(colIdx, rowIdx));\n\n      if (piece == null) {\n        boardAsString += \" \";\n      } else {\n        boardAsString += selectByPieceColor(piece.color, piece.toString().toUpperCase(), piece.toString());\n      }\n    }));\n    return boardAsString;\n  }\n  /**\r\n   * Set Board Row\r\n   * Sets the pieces for a specific row on the board\r\n   * @param {rowStr} Representation of the row as a string of [BOARD_WIDTH] characters\r\n   * @param {rowNum} Row number to identify the row. From 0 to [BOARD_HEIGHT]\r\n   */\n\n\n}","map":{"version":3,"sources":["C:/Users/jesus/Desktop/PG/Personal/1-Web/TS/OnlineChess/chessbackend/react-ui/src/domain/board.ts"],"names":["charToPiece","selectByPieceColor","PieceColor","King","Pawn","Knight","Queen","Rook","Bishop","getOpponent","pieceToChar","MoveState","Position","stringToMove","Move","moveToString","ERROR","BOARD_WIDTH","BOARD_HEIGHT","BoardObject","constructor","initTurn","initBoard","board","Array","fill","map","winner","turn","WHITE","moves","setPieceAt","position","piece","row","column","getPieceAt","findKingPosition","col","currentPosition","currentPiece","color","generateAllPossibleTargets","piecePosition","possibleEndPositions","Set","pieceAtEndPos","moveState","checkMove","OK","add","isInCheckMate","isInCheck","generateSafeKingTargets","size","kingPosition","possibleMovesForPiece","forEach","move","isPromotionMove","moveAsString","start","end","BLACK","makeMove","maybePromotionPiece","pieceChar","toUpperCase","toLowerCase","capturePiece","ALREADY_OVER","NO_PIECE_AT_START_POSITION","isPromotion","toString","hasMoved","updateWinner","push","setRow","rowStr","rowNum","colNum","undefined","console","log","stringMoves","fromMoves","baseBoard","possibleKingTargets","collisions","target","enemyPosition","enemyPiece","targetPiece","possibleEnemyTargets","direction","enemyTarget","delete","kingPos","collision","backupTurn","boardAsString","rowIdx","colIdx"],"mappings":"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","sourcesContent":["import {\r\n  Piece,\r\n  charToPiece,\r\n  selectByPieceColor,\r\n  PieceColor,\r\n  King,\r\n  Pawn,\r\n  Knight,\r\n  Queen,\r\n  Rook,\r\n  Bishop,\r\n  getOpponent,\r\n  pieceToChar,\r\n  MoveState\r\n} from './piece'\r\nimport { PositionObject, Position, stringToMove, Move, MoveObject, moveToString } from './position'\r\nimport ERROR from './errors'\r\n\r\nexport const BOARD_WIDTH = 8;\r\nexport const BOARD_HEIGHT = 8;\r\n\r\n\r\n/**\r\n * Board Object\r\n * Representation of a board and all it's permitted operations\r\n */\r\nexport class BoardObject {\r\n\r\n  board: Array<Array<Piece | null>> = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(null));\r\n  winner: PieceColor | null = null\r\n  turn: PieceColor = PieceColor.WHITE\r\n  moves: MoveObject[] = []\r\n\r\n  /**\r\n   * BoardObject Class contructor\r\n   * @param {initBoard} If true it will initialize this.board with pieces at default positions (true by default)\r\n   * @returns A new instance of BoardObject\r\n   */\r\n  constructor(initTurn: PieceColor | null = null, initBoard: boolean = true) {\r\n    if (initBoard) {\r\n      this.initBoard()\r\n    }\r\n    if (initTurn != null) {\r\n      this.turn = initTurn\r\n    }\r\n  }\r\n\r\n  stringMoves() {\r\n    return this.moves.map(move => moveToString(move))\r\n  }\r\n\r\n  /**\r\n   * Initialize Board\r\n   * Set the default rows with the default chess pieces in the current board\r\n   */\r\n  initBoard() {\r\n    // Set White pieces\r\n    this.setRow(\"rnbqkbnr\", 0)\r\n    this.setRow(\"pppppppp\", 1)\r\n    // Set Black pieces\r\n    this.setRow(\"PPPPPPPP\", BOARD_HEIGHT - 2)\r\n    this.setRow(\"RNBQKBNR\", BOARD_HEIGHT - 1)\r\n  }\r\n\r\n  static fromMoves(moves: string[]) {\r\n    const baseBoard = new BoardObject()\r\n    for (const move of moves) {\r\n      baseBoard.makeMove(move)\r\n    }\r\n    return baseBoard\r\n  }\r\n\r\n  /**\r\n   * Set Piece At\r\n   * Set a piece at a certain board position\r\n   * @param {position} Position in the board to put the new piece. Has a row and a column\r\n   * @param {piece} Piece to place at [position] in the board\r\n   * @returns A Piece if there is a piece at [position], null if not\r\n   */\r\n  setPieceAt = (position: PositionObject, piece: Piece | null) => this.board[position.row][position.column] = piece\r\n\r\n  /**\r\n   * Get Piece At\r\n   * Get the piece at a certain board position\r\n   * @param {position} Position in the board. Has a row and a column\r\n   * @returns A Piece if there is a piece at [position], null if not\r\n   */\r\n  getPieceAt = (position: PositionObject): Piece | null => this.board[position.row][position.column]\r\n\r\n  findKingPosition = (): PositionObject | null => {\r\n    for (let row = 0; row < BOARD_HEIGHT; row++) {\r\n      for (let col = 0; col < BOARD_WIDTH; col++) {\r\n        const currentPosition = Position(col, row)\r\n        const currentPiece = this.getPieceAt(currentPosition)\r\n\r\n        if (currentPiece instanceof King && this.turn == currentPiece.color)\r\n          return currentPosition\r\n      }\r\n    }\r\n    return null\r\n  }\r\n\r\n  generateAllPossibleTargets = (piecePosition: PositionObject): Set<PositionObject> => {\r\n    const possibleEndPositions = new Set<PositionObject>()\r\n    const piece = this.getPieceAt(piecePosition)\r\n    if (piece === null)\r\n      return possibleEndPositions\r\n\r\n    for (let row = 0; row < BOARD_HEIGHT; row++) {\r\n      for (let col = 0; col < BOARD_WIDTH; col++) {\r\n        const currentPosition = Position(col, row)\r\n        const pieceAtEndPos = this.getPieceAt(Position(col, row))\r\n\r\n        // If piece is from the same player trying to make the move don't try it\r\n        if (pieceAtEndPos != null && pieceAtEndPos.color == piece.color)\r\n          continue\r\n\r\n        const moveState = piece.checkMove(Move(pieceToChar(piece), piecePosition, currentPosition), this)\r\n\r\n        if (moveState == MoveState.OK) {\r\n          possibleEndPositions.add(currentPosition)\r\n        }\r\n      }\r\n    }\r\n    return possibleEndPositions\r\n  }\r\n\r\n  generateSafeKingTargets(): Set<PositionObject> {\r\n    const kingPosition = this.findKingPosition()\r\n\r\n    if (kingPosition == null)\r\n      return new Set<PositionObject>()\r\n\r\n    // Initial King Targets (Mutable set to remove in the end)\r\n    // Could also return a new Set with the exclusion of both Sets\r\n    const possibleKingTargets = this.generateAllPossibleTargets(kingPosition)\r\n\r\n    // Set that will store the suicide positions for the King\r\n    const collisions = new Set<PositionObject>()\r\n\r\n    this.setPieceAt(kingPosition, null)\r\n\r\n    possibleKingTargets.forEach((target) => {\r\n      // Remove King from the board to corretly make the predictions\r\n      // For all the board pieces\r\n      for (let row = 0; row < BOARD_HEIGHT; row++) {\r\n        for (let col = 0; col < BOARD_WIDTH; col++) {\r\n          const enemyPosition = Position(col, row)\r\n          const enemyPiece = this.getPieceAt(enemyPosition)\r\n\r\n          const targetPiece = this.getPieceAt(target)\r\n          this.setPieceAt(target, null)\r\n          /*\r\n           If Enemy Piece Generate it's possible moves and those that match the\r\n           king targets are added to the \"collisions\" Set\r\n           */\r\n          if (enemyPiece != null && enemyPiece.color != this.turn) {\r\n            const possibleEnemyTargets = this.generateAllPossibleTargets(enemyPosition)\r\n            /*\r\n             If piece is a pawn it can only eat in diagonal so moving forward is not a threat to King\r\n             */\r\n            if (enemyPiece instanceof Pawn) {\r\n              const direction = selectByPieceColor(this.turn, -1, 1)\r\n              // Add diagonals as Pawn targets\r\n              if (enemyPosition.column < BOARD_WIDTH - 1)\r\n                possibleEnemyTargets.add(Position(enemyPosition.column + 1, enemyPosition.row - direction))\r\n              if (enemyPosition.column > 0)\r\n                possibleEnemyTargets.add(Position(enemyPosition.column - 1, enemyPosition.row - direction))\r\n\r\n              // Remove targets in which pawn moves vertically\r\n              possibleEnemyTargets.forEach((enemyTarget: PositionObject) => {\r\n                if (enemyTarget.column == enemyPosition.column)\r\n                  possibleEnemyTargets.delete(enemyTarget)\r\n              })\r\n            }\r\n            // Remove suicide targets\r\n            possibleEnemyTargets.forEach((enemyTarget) => {\r\n              possibleKingTargets.forEach(target => {\r\n                if (enemyTarget.column === target.column && enemyTarget.row === target.row)\r\n                  collisions.add(enemyTarget)\r\n              })\r\n            })\r\n          }\r\n          // Put target piece back again\r\n          this.setPieceAt(target, targetPiece)\r\n        }\r\n      }\r\n    })\r\n\r\n    // Put King back to the board after predicting enemy targets\r\n    this.setPieceAt(kingPosition, new King(this.turn))\r\n    /*\r\n     Remove from the King targets the suicide positions\r\n     */\r\n    possibleKingTargets.forEach((kingPos: PositionObject) => {\r\n      collisions.forEach(collision => {\r\n        if (collision.column === kingPos.column && collision.row === kingPos.row)\r\n          possibleKingTargets.delete(kingPos)\r\n      })\r\n    })\r\n    return possibleKingTargets\r\n  }\r\n\r\n  isInCheckMate = () => this.isInCheck() && (this.generateSafeKingTargets().size === 0)\r\n\r\n  isInCheck = (): boolean => {\r\n    const kingPosition = this.findKingPosition()\r\n    if (kingPosition === null) return false\r\n\r\n    for (let row = 0; row < BOARD_HEIGHT; row++) {\r\n      for (let col = 0; col < BOARD_WIDTH; col++) {\r\n        const piecePosition = Position(col, row)\r\n        const piece = this.getPieceAt(piecePosition)\r\n        if (piece != null && piece.color == getOpponent(this.turn)) {\r\n          const possibleMovesForPiece = this.generateAllPossibleTargets(piecePosition)\r\n          possibleMovesForPiece.forEach(move => {\r\n            if (move.column === kingPosition.column && move.row === kingPosition.row)\r\n              return true\r\n          })\r\n        }\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  isPromotionMove = (moveAsString: string) => {\r\n    const move = stringToMove(moveAsString)\r\n    const piece = this.getPieceAt(move.start)\r\n    if (!(piece instanceof Pawn)) {\r\n      return false\r\n    }\r\n    if (this.turn == PieceColor.WHITE && move.end.row == 0) {\r\n      return true\r\n    }\r\n    if (this.turn == PieceColor.BLACK && move.end.row == 7) {\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  makeMove = (moveAsString: string) => {\r\n    const move = stringToMove(moveAsString)\r\n    const maybePromotionPiece = charToPiece(selectByPieceColor(this.turn, move.pieceChar.toUpperCase(), move.pieceChar.toLowerCase()))!!\r\n    const piece = this.getPieceAt(move.start)\r\n    const capturePiece = this.getPieceAt(move.end)\r\n\r\n    if (this.winner != null) {\r\n      throw ERROR.ALREADY_OVER\r\n    }\r\n\r\n    if (piece === null) throw ERROR.NO_PIECE_AT_START_POSITION\r\n\r\n    /*\r\n    if (!(piece instanceof King) && this.isInCheck()) {\r\n      throw ERROR.KING_IN_CHECK\r\n    }\r\n    */\r\n\r\n    const isPromotion = maybePromotionPiece.toString().toUpperCase() != piece.toString().toUpperCase()\r\n\r\n    if (\r\n      // When true means Promotion\r\n      isPromotion &&\r\n      // Check if it is a Pawn and if it's not a game winning move\r\n      (piece instanceof Pawn) && !(capturePiece instanceof King) &&\r\n      // Check if it's valid promotion piece\r\n      (maybePromotionPiece instanceof Knight || maybePromotionPiece instanceof Queen || maybePromotionPiece instanceof Bishop || maybePromotionPiece instanceof Rook)\r\n    ) {\r\n      // Transform pawn\r\n      this.setPieceAt(move.end, maybePromotionPiece)\r\n      this.setPieceAt(move.start, null)\r\n    } else {\r\n      this.setPieceAt(move.end, piece)\r\n      this.setPieceAt(move.start, null)\r\n    }\r\n\r\n    if (piece instanceof Pawn)\r\n      piece.hasMoved = true\r\n\r\n    // If this move makes the other player's King be in check and with nowhere to go tell board he won\r\n    if (this.isInCheck() && this.generateSafeKingTargets().size === 0)\r\n      this.winner = getOpponent(this.turn)\r\n\r\n    this.turn = getOpponent(this.turn)\r\n\r\n    this.updateWinner()\r\n    this.moves.push(move)\r\n  }\r\n\r\n  updateWinner() {\r\n    if (this.findKingPosition() == null) {\r\n      this.winner = getOpponent(this.turn)\r\n    }\r\n    const backupTurn = this.turn\r\n    this.turn = getOpponent(this.turn)\r\n\r\n    if (this.findKingPosition() == null) {\r\n      this.winner = getOpponent(this.turn)\r\n    }\r\n    this.turn = backupTurn\r\n  }\r\n\r\n  /**\r\n   * Board to String\r\n   * Convert the current board to a string\r\n   * @returns a string representation of this.board\r\n   */\r\n  toString() {\r\n    var boardAsString: string = \"\"\r\n    this.board.map((row, rowIdx) => row.map((col, colIdx) => {\r\n      const piece = this.getPieceAt(Position(colIdx, rowIdx))\r\n      if (piece == null) {\r\n        boardAsString += \" \"\r\n      } else {\r\n        boardAsString += selectByPieceColor(piece.color, piece.toString().toUpperCase(), piece.toString())\r\n      }\r\n    }))\r\n    return boardAsString\r\n  }\r\n\r\n  /**\r\n   * Set Board Row\r\n   * Sets the pieces for a specific row on the board\r\n   * @param {rowStr} Representation of the row as a string of [BOARD_WIDTH] characters\r\n   * @param {rowNum} Row number to identify the row. From 0 to [BOARD_HEIGHT]\r\n   */\r\n  setRow = (rowStr: string, rowNum: number) => {\r\n    for (let colNum = 0; colNum < BOARD_WIDTH; colNum++) {\r\n      const pieceChar = rowStr[colNum]\r\n      if (pieceChar !== undefined) {\r\n        console.log(\"setting piece:\", Position(colNum, rowNum), charToPiece(pieceChar))\r\n        this.setPieceAt(Position(colNum, rowNum), charToPiece(pieceChar))\r\n      }\r\n    }\r\n    console.log(this.findKingPosition())\r\n    console.log(this.toString())\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}