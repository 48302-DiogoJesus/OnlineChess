{"ast":null,"code":"import { charToPiece, selectByPieceColor, PieceColor, King, Pawn, Knight, Queen, Rook, Bishop, getOpponent, pieceToChar, MoveState } from './piece';\nimport { Position, stringToMove, Move } from './position';\nimport ERROR from './errors';\nexport const BOARD_WIDTH = 8;\nexport const BOARD_HEIGHT = 8;\n/**\r\n * Board Object\r\n * Representation of a board and all it's permitted operations\r\n */\n\nexport class BoardObject {\n  /**\r\n   * BoardObject Class contructor\r\n   * @param {initBoard} If true it will initialize this.board with pieces at default positions (true by default)\r\n   * @returns A new instance of BoardObject\r\n   */\n  constructor() {\n    let initTurn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let initBoard = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.board = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(null));\n    this.winner = null;\n    this.turn = PieceColor.WHITE;\n\n    this.setPieceAt = (position, piece) => this.board[position.row][position.column] = piece;\n\n    this.getPieceAt = position => this.board[position.row][position.column];\n\n    this.findKingPosition = () => {\n      for (let row = 0; row < BOARD_HEIGHT; row++) {\n        for (let col = 0; col < BOARD_WIDTH; col++) {\n          const currentPosition = Position(col, row);\n          const currentPiece = this.getPieceAt(currentPosition);\n          if (currentPiece instanceof King && this.turn == currentPiece.color) return currentPosition;\n        }\n      }\n\n      return null;\n    };\n\n    this.generateAllPossibleTargets = piecePosition => {\n      const possibleEndPositions = new Set();\n      const piece = this.getPieceAt(piecePosition);\n      if (piece === null) return possibleEndPositions;\n\n      for (let row = 0; row < BOARD_HEIGHT; row++) {\n        for (let col = 0; col < BOARD_WIDTH; col++) {\n          const currentPosition = Position(col, row);\n          const pieceAtEndPos = this.getPieceAt(Position(col, row)); // If piece is from the same player trying to make the move don't try it\n\n          if (pieceAtEndPos != null && pieceAtEndPos.color == piece.color) continue;\n          const moveState = piece.checkMove(Move(pieceToChar(piece), piecePosition, currentPosition), this);\n\n          if (moveState == MoveState.OK) {\n            possibleEndPositions.add(currentPosition);\n          }\n        }\n      }\n\n      return possibleEndPositions;\n    };\n\n    this.isInCheckMate = () => this.isInCheck() && this.generateSafeKingTargets().size === 0;\n\n    this.isInCheck = () => {\n      const kingPosition = this.findKingPosition();\n      if (kingPosition === null) return false;\n\n      for (let row = 0; row < BOARD_HEIGHT; row++) {\n        for (let col = 0; col < BOARD_WIDTH; col++) {\n          const piecePosition = Position(col, row);\n          const piece = this.getPieceAt(piecePosition);\n\n          if (piece != null && piece.color == getOpponent(this.turn)) {\n            const possibleMovesForPiece = this.generateAllPossibleTargets(piecePosition);\n            possibleMovesForPiece.forEach(move => {\n              if (move.column === kingPosition.column && move.row === kingPosition.row) return true;\n            });\n          }\n        }\n      }\n\n      return false;\n    };\n\n    this.makeMove = moveAsString => {\n      const move = stringToMove(moveAsString);\n      const maybePromotionPiece = charToPiece(selectByPieceColor(this.turn, move.pieceChar.toUpperCase(), move.pieceChar.toLowerCase()));\n      const piece = this.getPieceAt(move.start);\n      const capturePiece = this.getPieceAt(move.end);\n\n      if (this.winner != null) {\n        throw ERROR.ALREADY_OVER;\n      }\n\n      if (piece === null) throw ERROR.NO_PIECE_AT_START_POSITION;\n\n      if (!(piece instanceof King) && this.isInCheck()) {\n        throw ERROR.KING_IN_CHECK;\n      }\n\n      if ( // When true means Promotion\n      maybePromotionPiece.toString().toUpperCase() != piece.toString().toUpperCase() && // Check if it is a Pawn and if it's not a game winning move\n      piece instanceof Pawn && !(capturePiece instanceof King) && ( // Check if it's valid promotion piece\n      maybePromotionPiece instanceof Knight || maybePromotionPiece instanceof Queen || maybePromotionPiece instanceof Bishop || maybePromotionPiece instanceof Rook)) {\n        // Transform pawn\n        this.setPieceAt(move.end, maybePromotionPiece);\n        this.setPieceAt(move.start, null);\n      } else {\n        this.setPieceAt(move.end, piece);\n        this.setPieceAt(move.start, null);\n      }\n\n      if (piece instanceof Pawn) piece.hasMoved = true; // If this move makes the other player's King be in check and with nowhere to go tell board he won\n\n      if (this.isInCheck() && this.generateSafeKingTargets().size === 0) this.winner = getOpponent(this.turn);\n      this.turn = getOpponent(this.turn);\n      this.updateWinner();\n    };\n\n    this.setRow = (rowStr, rowNum) => {\n      for (let colNum = 0; colNum < BOARD_WIDTH; colNum++) {\n        const pieceChar = rowStr[colNum];\n\n        if (pieceChar !== undefined) {\n          this.setPieceAt(Position(colNum, rowNum), charToPiece(rowStr[colNum]));\n        }\n      }\n    };\n\n    if (initBoard) {\n      this.initBoard();\n    }\n\n    if (initTurn != null) {\n      this.turn = initTurn;\n    }\n  }\n  /**\r\n   * Initialize Board\r\n   * Set the default rows with the default chess pieces in the current board\r\n   */\n\n\n  initBoard() {\n    // Set White pieces\n    this.setRow(\"rnbqkbnr\", 0);\n    this.setRow(\"pppppppp\", 1); // Set Black pieces\n\n    this.setRow(\"PPPPPPPP\", BOARD_HEIGHT - 2);\n    this.setRow(\"RNBQKBNR\", BOARD_HEIGHT - 1);\n  }\n\n  static fromMoves(moves) {\n    for (const move of moves) {\n      console.log(move);\n    }\n  }\n  /**\r\n   * Set Piece At\r\n   * Set a piece at a certain board position\r\n   * @param {position} Position in the board to put the new piece. Has a row and a column\r\n   * @param {piece} Piece to place at [position] in the board\r\n   * @returns A Piece if there is a piece at [position], null if not\r\n   */\n\n\n  generateSafeKingTargets() {\n    const kingPosition = this.findKingPosition();\n    if (kingPosition == null) return new Set(); // Initial King Targets (Mutable set to remove in the end)\n    // Could also return a new Set with the exclusion of both Sets\n\n    const possibleKingTargets = this.generateAllPossibleTargets(kingPosition); // Set that will store the suicide positions for the King\n\n    const collisions = new Set();\n    this.setPieceAt(kingPosition, null);\n    possibleKingTargets.forEach(target => {\n      // Remove King from the board to corretly make the predictions\n      // For all the board pieces\n      for (let row = 0; row < BOARD_HEIGHT; row++) {\n        for (let col = 0; col < BOARD_WIDTH; col++) {\n          const enemyPosition = Position(col, row);\n          const enemyPiece = this.getPieceAt(enemyPosition);\n          const targetPiece = this.getPieceAt(target);\n          this.setPieceAt(target, null);\n          /*\r\n           If Enemy Piece Generate it's possible moves and those that match the\r\n           king targets are added to the \"collisions\" Set\r\n           */\n\n          if (enemyPiece != null && enemyPiece.color != this.turn) {\n            const possibleEnemyTargets = this.generateAllPossibleTargets(enemyPosition);\n            /*\r\n             If piece is a pawn it can only eat in diagonal so moving forward is not a threat to King\r\n             */\n\n            if (enemyPiece instanceof Pawn) {\n              const direction = selectByPieceColor(this.turn, -1, 1); // Add diagonals as Pawn targets\n\n              if (enemyPosition.column < BOARD_WIDTH - 1) possibleEnemyTargets.add(Position(enemyPosition.column + 1, enemyPosition.row - direction));\n              if (enemyPosition.column > 0) possibleEnemyTargets.add(Position(enemyPosition.column - 1, enemyPosition.row - direction)); // Remove targets in which pawn moves vertically\n\n              possibleEnemyTargets.forEach(enemyTarget => {\n                if (enemyTarget.column == enemyPosition.column) possibleEnemyTargets.delete(enemyTarget);\n              });\n            } // Remove suicide targets\n\n\n            possibleEnemyTargets.forEach(enemyTarget => {\n              possibleKingTargets.forEach(target => {\n                if (enemyTarget.column === target.column && enemyTarget.row === target.row) collisions.add(enemyTarget);\n              });\n            });\n          } // Put target piece back again\n\n\n          this.setPieceAt(target, targetPiece);\n        }\n      }\n    }); // Put King back to the board after predicting enemy targets\n\n    this.setPieceAt(kingPosition, new King(this.turn));\n    /*\r\n     Remove from the King targets the suicide positions\r\n     */\n\n    possibleKingTargets.forEach(kingPos => {\n      collisions.forEach(collision => {\n        if (collision.column === kingPos.column && collision.row === kingPos.row) possibleKingTargets.delete(kingPos);\n      });\n    });\n    return possibleKingTargets;\n  }\n\n  updateWinner() {\n    if (this.findKingPosition() == null) {\n      this.winner = getOpponent(this.turn);\n    }\n\n    const backupTurn = this.turn;\n    this.turn = getOpponent(this.turn);\n\n    if (this.findKingPosition() == null) {\n      this.winner = getOpponent(this.turn);\n    }\n\n    this.turn = backupTurn;\n  }\n  /**\r\n   * Board to String\r\n   * Convert the current board to a string\r\n   * @returns a string representation of this.board\r\n   */\n\n\n  toString() {\n    var boardAsString = \"\";\n    this.board.map((row, rowIdx) => row.map((col, colIdx) => {\n      const piece = this.getPieceAt(Position(colIdx, rowIdx));\n\n      if (piece == null) {\n        boardAsString += \" \";\n      } else {\n        boardAsString += selectByPieceColor(piece.color, piece.toString().toUpperCase(), piece.toString());\n      }\n    }));\n    return boardAsString;\n  }\n  /**\r\n   * Set Board Row\r\n   * Sets the pieces for a specific row on the board\r\n   * @param {rowStr} Representation of the row as a string of [BOARD_WIDTH] characters\r\n   * @param {rowNum} Row number to identify the row. From 0 to [BOARD_HEIGHT]\r\n   */\n\n\n}\n/**\r\n * String to Board\r\n * Convert a string to a board\r\n * If a char corresponds to a valid piece set that piece in the {newBoard}, if not set an empty Tile in the {newBoard}\r\n * @param {boardAsString} Example of a default board: \"rnbqkbnrpppppppp                                PPPPPPPPRNBQKBNR\"\r\n * @returns A new BoardObject if {boardAsString} is convertible to a board, null if not\r\n */\n\nexport function stringToBoard(boardAsString) {\n  let initTurn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (boardAsString.length != BOARD_WIDTH * BOARD_HEIGHT) throw ERROR.BAD_BOARD_STRING;\n  var blackHasKing = false;\n  var whiteHasKing = false;\n  const newBoard = new BoardObject(initTurn, false);\n\n  for (let row = 0, currChar = 0; row < BOARD_HEIGHT; row++) {\n    for (let col = 0; col < BOARD_WIDTH; col++, currChar++) {\n      const pieceChar = boardAsString[currChar];\n      const piece = charToPiece(pieceChar);\n\n      if (piece instanceof King) {\n        if (piece.color == PieceColor.WHITE) {\n          whiteHasKing = true;\n        } else if (piece.color == PieceColor.BLACK) {\n          blackHasKing = true;\n        }\n      } // [piece] will be null if char does not correspond to a piece. Case of the \" \" representing an empty Tile\n\n\n      newBoard.setPieceAt(Position(col, row), piece);\n    }\n  }\n\n  if (!blackHasKing) newBoard.winner = PieceColor.WHITE;\n  if (!whiteHasKing) newBoard.winner = PieceColor.BLACK;\n  return newBoard;\n}\nconst moves = [stringToMove(\"Pb1b2\")];\nconsole.log(moves); // console.log(BoardObject.fromMoves(moves))","map":{"version":3,"sources":["C:/Users/jesus/Desktop/PG/Personal/1-Web/TS/OnlineChess/onlinechess/src/domain/board.ts"],"names":["charToPiece","selectByPieceColor","PieceColor","King","Pawn","Knight","Queen","Rook","Bishop","getOpponent","pieceToChar","MoveState","Position","stringToMove","Move","ERROR","BOARD_WIDTH","BOARD_HEIGHT","BoardObject","constructor","initTurn","initBoard","board","Array","fill","map","winner","turn","WHITE","setPieceAt","position","piece","row","column","getPieceAt","findKingPosition","col","currentPosition","currentPiece","color","generateAllPossibleTargets","piecePosition","possibleEndPositions","Set","pieceAtEndPos","moveState","checkMove","OK","add","isInCheckMate","isInCheck","generateSafeKingTargets","size","kingPosition","possibleMovesForPiece","forEach","move","makeMove","moveAsString","maybePromotionPiece","pieceChar","toUpperCase","toLowerCase","start","capturePiece","end","ALREADY_OVER","NO_PIECE_AT_START_POSITION","KING_IN_CHECK","toString","hasMoved","updateWinner","setRow","rowStr","rowNum","colNum","undefined","fromMoves","moves","console","log","possibleKingTargets","collisions","target","enemyPosition","enemyPiece","targetPiece","possibleEnemyTargets","direction","enemyTarget","delete","kingPos","collision","backupTurn","boardAsString","rowIdx","colIdx","stringToBoard","length","BAD_BOARD_STRING","blackHasKing","whiteHasKing","newBoard","currChar","BLACK"],"mappings":"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","sourcesContent":["import {\r\n  Piece,\r\n  charToPiece,\r\n  selectByPieceColor,\r\n  PieceColor,\r\n  King,\r\n  Pawn,\r\n  Knight,\r\n  Queen,\r\n  Rook,\r\n  Bishop,\r\n  getOpponent,\r\n  pieceToChar,\r\n  MoveState\r\n} from './piece'\r\nimport { PositionObject, Position, stringToMove, Move, MoveObject } from './position'\r\nimport ERROR from './errors'\r\n\r\nexport const BOARD_WIDTH = 8;\r\nexport const BOARD_HEIGHT = 8;\r\n\r\n\r\n/**\r\n * Board Object\r\n * Representation of a board and all it's permitted operations\r\n */\r\nexport class BoardObject {\r\n\r\n  board: Array<Array<Piece | null>> = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(null));\r\n  winner: PieceColor | null = null\r\n  turn: PieceColor = PieceColor.WHITE\r\n\r\n  /**\r\n   * BoardObject Class contructor\r\n   * @param {initBoard} If true it will initialize this.board with pieces at default positions (true by default)\r\n   * @returns A new instance of BoardObject\r\n   */\r\n  constructor(initTurn: PieceColor | null = null, initBoard: boolean = true) {\r\n    if (initBoard) {\r\n      this.initBoard()\r\n    }\r\n    if (initTurn != null) {\r\n      this.turn = initTurn\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize Board\r\n   * Set the default rows with the default chess pieces in the current board\r\n   */\r\n  initBoard() {\r\n    // Set White pieces\r\n    this.setRow(\"rnbqkbnr\", 0)\r\n    this.setRow(\"pppppppp\", 1)\r\n    // Set Black pieces\r\n    this.setRow(\"PPPPPPPP\", BOARD_HEIGHT - 2)\r\n    this.setRow(\"RNBQKBNR\", BOARD_HEIGHT - 1)\r\n  }\r\n\r\n  static fromMoves(moves: MoveObject[]) {\r\n    for (const move of moves) {\r\n      console.log(move)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set Piece At\r\n   * Set a piece at a certain board position\r\n   * @param {position} Position in the board to put the new piece. Has a row and a column\r\n   * @param {piece} Piece to place at [position] in the board\r\n   * @returns A Piece if there is a piece at [position], null if not\r\n   */\r\n  setPieceAt = (position: PositionObject, piece: Piece | null) => this.board[position.row][position.column] = piece\r\n\r\n  /**\r\n   * Get Piece At\r\n   * Get the piece at a certain board position\r\n   * @param {position} Position in the board. Has a row and a column\r\n   * @returns A Piece if there is a piece at [position], null if not\r\n   */\r\n  getPieceAt = (position: PositionObject): Piece | null => this.board[position.row][position.column]\r\n\r\n  findKingPosition = (): PositionObject | null => {\r\n    for (let row = 0; row < BOARD_HEIGHT; row++) {\r\n      for (let col = 0; col < BOARD_WIDTH; col++) {\r\n        const currentPosition = Position(col, row)\r\n        const currentPiece = this.getPieceAt(currentPosition)\r\n\r\n        if (currentPiece instanceof King && this.turn == currentPiece.color)\r\n          return currentPosition\r\n      }\r\n    }\r\n    return null\r\n  }\r\n\r\n  generateAllPossibleTargets = (piecePosition: PositionObject): Set<PositionObject> => {\r\n    const possibleEndPositions = new Set<PositionObject>()\r\n    const piece = this.getPieceAt(piecePosition)\r\n    if (piece === null)\r\n      return possibleEndPositions\r\n\r\n    for (let row = 0; row < BOARD_HEIGHT; row++) {\r\n      for (let col = 0; col < BOARD_WIDTH; col++) {\r\n        const currentPosition = Position(col, row)\r\n        const pieceAtEndPos = this.getPieceAt(Position(col, row))\r\n\r\n        // If piece is from the same player trying to make the move don't try it\r\n        if (pieceAtEndPos != null && pieceAtEndPos.color == piece.color)\r\n          continue\r\n\r\n        const moveState = piece.checkMove(Move(pieceToChar(piece), piecePosition, currentPosition), this)\r\n\r\n        if (moveState == MoveState.OK) {\r\n          possibleEndPositions.add(currentPosition)\r\n        }\r\n      }\r\n    }\r\n    return possibleEndPositions\r\n  }\r\n\r\n  generateSafeKingTargets(): Set<PositionObject> {\r\n    const kingPosition = this.findKingPosition()\r\n\r\n    if (kingPosition == null)\r\n      return new Set<PositionObject>()\r\n\r\n    // Initial King Targets (Mutable set to remove in the end)\r\n    // Could also return a new Set with the exclusion of both Sets\r\n    const possibleKingTargets = this.generateAllPossibleTargets(kingPosition)\r\n\r\n    // Set that will store the suicide positions for the King\r\n    const collisions = new Set<PositionObject>()\r\n\r\n    this.setPieceAt(kingPosition, null)\r\n\r\n    possibleKingTargets.forEach((target) => {\r\n      // Remove King from the board to corretly make the predictions\r\n      // For all the board pieces\r\n      for (let row = 0; row < BOARD_HEIGHT; row++) {\r\n        for (let col = 0; col < BOARD_WIDTH; col++) {\r\n          const enemyPosition = Position(col, row)\r\n          const enemyPiece = this.getPieceAt(enemyPosition)\r\n\r\n          const targetPiece = this.getPieceAt(target)\r\n          this.setPieceAt(target, null)\r\n          /*\r\n           If Enemy Piece Generate it's possible moves and those that match the\r\n           king targets are added to the \"collisions\" Set\r\n           */\r\n          if (enemyPiece != null && enemyPiece.color != this.turn) {\r\n            const possibleEnemyTargets = this.generateAllPossibleTargets(enemyPosition)\r\n            /*\r\n             If piece is a pawn it can only eat in diagonal so moving forward is not a threat to King\r\n             */\r\n            if (enemyPiece instanceof Pawn) {\r\n              const direction = selectByPieceColor(this.turn, -1, 1)\r\n              // Add diagonals as Pawn targets\r\n              if (enemyPosition.column < BOARD_WIDTH - 1)\r\n                possibleEnemyTargets.add(Position(enemyPosition.column + 1, enemyPosition.row - direction))\r\n              if (enemyPosition.column > 0)\r\n                possibleEnemyTargets.add(Position(enemyPosition.column - 1, enemyPosition.row - direction))\r\n\r\n              // Remove targets in which pawn moves vertically\r\n              possibleEnemyTargets.forEach((enemyTarget: PositionObject) => {\r\n                if (enemyTarget.column == enemyPosition.column)\r\n                  possibleEnemyTargets.delete(enemyTarget)\r\n              })\r\n            }\r\n            // Remove suicide targets\r\n            possibleEnemyTargets.forEach((enemyTarget) => {\r\n              possibleKingTargets.forEach(target => {\r\n                if (enemyTarget.column === target.column && enemyTarget.row === target.row)\r\n                  collisions.add(enemyTarget)\r\n              })\r\n            })\r\n          }\r\n          // Put target piece back again\r\n          this.setPieceAt(target, targetPiece)\r\n        }\r\n      }\r\n    })\r\n\r\n    // Put King back to the board after predicting enemy targets\r\n    this.setPieceAt(kingPosition, new King(this.turn))\r\n    /*\r\n     Remove from the King targets the suicide positions\r\n     */\r\n    possibleKingTargets.forEach((kingPos: PositionObject) => {\r\n      collisions.forEach(collision => {\r\n        if (collision.column === kingPos.column && collision.row === kingPos.row)\r\n          possibleKingTargets.delete(kingPos)\r\n      })\r\n    })\r\n    return possibleKingTargets\r\n  }\r\n\r\n  isInCheckMate = () => this.isInCheck() && (this.generateSafeKingTargets().size === 0)\r\n\r\n  isInCheck = (): boolean => {\r\n    const kingPosition = this.findKingPosition()\r\n    if (kingPosition === null) return false\r\n\r\n    for (let row = 0; row < BOARD_HEIGHT; row++) {\r\n      for (let col = 0; col < BOARD_WIDTH; col++) {\r\n        const piecePosition = Position(col, row)\r\n        const piece = this.getPieceAt(piecePosition)\r\n        if (piece != null && piece.color == getOpponent(this.turn)) {\r\n          const possibleMovesForPiece = this.generateAllPossibleTargets(piecePosition)\r\n          possibleMovesForPiece.forEach(move => {\r\n            if (move.column === kingPosition.column && move.row === kingPosition.row)\r\n              return true\r\n          })\r\n        }\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  makeMove = (moveAsString: string) => {\r\n    const move = stringToMove(moveAsString)\r\n    const maybePromotionPiece = charToPiece(selectByPieceColor(this.turn, move.pieceChar.toUpperCase(), move.pieceChar.toLowerCase()))!!\r\n    const piece = this.getPieceAt(move.start)\r\n    const capturePiece = this.getPieceAt(move.end)\r\n\r\n    if (this.winner != null) {\r\n      throw ERROR.ALREADY_OVER\r\n    }\r\n\r\n    if (piece === null) throw ERROR.NO_PIECE_AT_START_POSITION\r\n\r\n    if (!(piece instanceof King) && this.isInCheck()) {\r\n      throw ERROR.KING_IN_CHECK\r\n    }\r\n\r\n    if (\r\n      // When true means Promotion\r\n      maybePromotionPiece.toString().toUpperCase() != piece.toString().toUpperCase() &&\r\n      // Check if it is a Pawn and if it's not a game winning move\r\n      (piece instanceof Pawn) && !(capturePiece instanceof King) &&\r\n      // Check if it's valid promotion piece\r\n      (maybePromotionPiece instanceof Knight || maybePromotionPiece instanceof Queen || maybePromotionPiece instanceof Bishop || maybePromotionPiece instanceof Rook)\r\n    ) {\r\n      // Transform pawn\r\n      this.setPieceAt(move.end, maybePromotionPiece)\r\n      this.setPieceAt(move.start, null)\r\n    } else {\r\n      this.setPieceAt(move.end, piece)\r\n      this.setPieceAt(move.start, null)\r\n    }\r\n\r\n    if (piece instanceof Pawn)\r\n      piece.hasMoved = true\r\n\r\n    // If this move makes the other player's King be in check and with nowhere to go tell board he won\r\n    if (this.isInCheck() && this.generateSafeKingTargets().size === 0)\r\n      this.winner = getOpponent(this.turn)\r\n\r\n    this.turn = getOpponent(this.turn)\r\n\r\n    this.updateWinner()\r\n  }\r\n\r\n  updateWinner() {\r\n    if (this.findKingPosition() == null) {\r\n      this.winner = getOpponent(this.turn)\r\n    }\r\n    const backupTurn = this.turn\r\n    this.turn = getOpponent(this.turn)\r\n\r\n    if (this.findKingPosition() == null) {\r\n      this.winner = getOpponent(this.turn)\r\n    }\r\n    this.turn = backupTurn\r\n  }\r\n\r\n  /**\r\n   * Board to String\r\n   * Convert the current board to a string\r\n   * @returns a string representation of this.board\r\n   */\r\n  toString() {\r\n    var boardAsString: string = \"\"\r\n    this.board.map((row, rowIdx) => row.map((col, colIdx) => {\r\n      const piece = this.getPieceAt(Position(colIdx, rowIdx))\r\n      if (piece == null) {\r\n        boardAsString += \" \"\r\n      } else {\r\n        boardAsString += selectByPieceColor(piece.color, piece.toString().toUpperCase(), piece.toString())\r\n      }\r\n    }))\r\n    return boardAsString\r\n  }\r\n\r\n  /**\r\n   * Set Board Row\r\n   * Sets the pieces for a specific row on the board\r\n   * @param {rowStr} Representation of the row as a string of [BOARD_WIDTH] characters\r\n   * @param {rowNum} Row number to identify the row. From 0 to [BOARD_HEIGHT]\r\n   */\r\n  setRow = (rowStr: string, rowNum: number) => {\r\n    for (let colNum = 0; colNum < BOARD_WIDTH; colNum++) {\r\n      const pieceChar = rowStr[colNum]\r\n      if (pieceChar !== undefined) {\r\n        this.setPieceAt(Position(colNum, rowNum), charToPiece(rowStr[colNum])!!)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * String to Board\r\n * Convert a string to a board\r\n * If a char corresponds to a valid piece set that piece in the {newBoard}, if not set an empty Tile in the {newBoard}\r\n * @param {boardAsString} Example of a default board: \"rnbqkbnrpppppppp                                PPPPPPPPRNBQKBNR\"\r\n * @returns A new BoardObject if {boardAsString} is convertible to a board, null if not\r\n */\r\nexport function stringToBoard(boardAsString: string, initTurn: PieceColor | null = null): BoardObject {\r\n  if (boardAsString.length != BOARD_WIDTH * BOARD_HEIGHT)\r\n    throw ERROR.BAD_BOARD_STRING\r\n\r\n  var blackHasKing = false\r\n  var whiteHasKing = false\r\n\r\n  const newBoard = new BoardObject(initTurn, false)\r\n  for (let row = 0, currChar = 0; row < BOARD_HEIGHT; row++) {\r\n    for (let col = 0; col < BOARD_WIDTH; col++, currChar++) {\r\n      const pieceChar = boardAsString[currChar]\r\n      const piece: Piece | null = charToPiece(pieceChar)\r\n      if (piece instanceof King) {\r\n        if (piece.color == PieceColor.WHITE) {\r\n          whiteHasKing = true\r\n        } else if (piece.color == PieceColor.BLACK) {\r\n          blackHasKing = true\r\n        }\r\n      }\r\n      // [piece] will be null if char does not correspond to a piece. Case of the \" \" representing an empty Tile\r\n      newBoard.setPieceAt(Position(col, row), piece)\r\n    }\r\n  }\r\n  if (!blackHasKing)\r\n    newBoard.winner = PieceColor.WHITE\r\n  if (!whiteHasKing)\r\n    newBoard.winner = PieceColor.BLACK\r\n  return newBoard\r\n}\r\n\r\nconst moves: MoveObject[] = [\r\n  stringToMove(\"Pb1b2\")\r\n]\r\nconsole.log(moves)\r\n// console.log(BoardObject.fromMoves(moves))\r\n"]},"metadata":{},"sourceType":"module"}